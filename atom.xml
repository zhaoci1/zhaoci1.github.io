<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朝辞</title>
  
  
  <link href="http://zhaocil.tech/atom.xml" rel="self"/>
  
  <link href="http://zhaocil.tech/"/>
  <updated>2022-04-27T06:40:29.564Z</updated>
  <id>http://zhaocil.tech/</id>
  
  <author>
    <name>朝辞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对象</title>
    <link href="http://zhaocil.tech/2022/04/25/%E5%AF%B9%E8%B1%A1/"/>
    <id>http://zhaocil.tech/2022/04/25/%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-04-25T08:11:43.000Z</published>
    <updated>2022-04-27T06:40:29.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 对象名 = &#123;属性<span class="number">1</span>，属性<span class="number">2</span>，属性<span class="number">3.</span>..&#125;</span><br></pre></td></tr></table></figure><p>数组通过下标访问数据，对象通过属性名访问数据</p><h2 id="访问数据的方法"><a href="#访问数据的方法" class="headerlink" title="访问数据的方法"></a>访问数据的方法</h2><ol><li>对象名.属性名</li><li>对象名[‘属性名’] (可以用一个变量来存储属性名)</li></ol><p>对面里面也可以存函数，这个函数叫做这个对象的方法</p><h2 id="方法里面的-this-指向"><a href="#方法里面的-this-指向" class="headerlink" title="方法里面的 this 指向"></a>方法里面的 this 指向</h2><p>谁调用方法，this 就代表哪个对象</p><p>数组实际上是一种特殊的对象，它们有自己的方法<br>例如：push,unshift</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;定义对象&quot;&gt;&lt;a href=&quot;#定义对象&quot; class=&quot;headerlink&quot; title=&quot;定义对象&quot;&gt;&lt;/a&gt;定义对象&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    
    <category term="js" scheme="http://zhaocil.tech/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://zhaocil.tech/2022/04/25/%E6%95%B0%E7%BB%84/"/>
    <id>http://zhaocil.tech/2022/04/25/%E6%95%B0%E7%BB%84/</id>
    <published>2022-04-25T01:53:14.000Z</published>
    <updated>2022-04-27T06:40:23.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建数组的方法"><a href="#创建数组的方法" class="headerlink" title="创建数组的方法"></a>创建数组的方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> 数组名 = [元素<span class="number">1</span>，元素<span class="number">2</span>，元素<span class="number">3.</span>..]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> 数组名 <span class="keyword">new</span> <span class="title class_">Array</span>(元素<span class="number">1</span>，元素<span class="number">2</span>，元素<span class="number">3.</span>..)</span><br></pre></td></tr></table></figure><p>数组下标通常以 0 开始</p><p>数组名.length(length 能获取数组中元素的个数)</p><p>以 const 声明的数组，后面可以改变它的值</p><p>数组内的元素可以是任意表达式，例如：函数，字符串，数字等等</p><hr><h1 id="内置数组函数"><a href="#内置数组函数" class="headerlink" title="内置数组函数"></a>内置数组函数</h1><h2 id="在数组末尾添加元素"><a href="#在数组末尾添加元素" class="headerlink" title="在数组末尾添加元素"></a>在数组末尾添加元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.<span class="title function_">push</span>(要添加的元素);</span><br></pre></td></tr></table></figure><h2 id="在数组开头添加元素"><a href="#在数组开头添加元素" class="headerlink" title="在数组开头添加元素"></a>在数组开头添加元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.<span class="title function_">unshift</span>(要添加的元素);</span><br></pre></td></tr></table></figure><p><strong>上面两个内置函数有返回值，返回值是新数组的长度</strong></p><h2 id="删除数组最后一个元素"><a href="#删除数组最后一个元素" class="headerlink" title="删除数组最后一个元素"></a>删除数组最后一个元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组名.<span class="title function_">pop</span>();</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h2 id="删除数组的第一个元素"><a href="#删除数组的第一个元素" class="headerlink" title="删除数组的第一个元素"></a>删除数组的第一个元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.<span class="title function_">unshift</span>(要删除的元素);</span><br></pre></td></tr></table></figure><p><strong>上面两个内置函数有返回值，返回值是被删除的元素</strong></p><h2 id="删除数组的第一个元素-1"><a href="#删除数组的第一个元素-1" class="headerlink" title="删除数组的第一个元素"></a>删除数组的第一个元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.<span class="title function_">unshift</span>(要删除的元素);</span><br></pre></td></tr></table></figure><h2 id="查询数组中某个元素的下标"><a href="#查询数组中某个元素的下标" class="headerlink" title="查询数组中某个元素的下标"></a>查询数组中某个元素的下标</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.<span class="title function_">indexOf</span>(要查找的元素);</span><br></pre></td></tr></table></figure><p><strong>如果有，则返回该元素对应的下标</strong></p><p><strong>如果没找到该元素，则返回-1</strong></p><h2 id="查询数组中是否包含某个元素"><a href="#查询数组中是否包含某个元素" class="headerlink" title="查询数组中是否包含某个元素"></a>查询数组中是否包含某个元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.<span class="title function_">includes</span>(要查找的元素);</span><br></pre></td></tr></table></figure><p>有则返回 true,<br>无则返回 false</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建数组的方法&quot;&gt;&lt;a href=&quot;#创建数组的方法&quot; class=&quot;headerlink&quot; title=&quot;创建数组的方法&quot;&gt;&lt;/a&gt;创建数组的方法&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu</summary>
      
    
    
    
    
    <category term="js" scheme="http://zhaocil.tech/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS函数</title>
    <link href="http://zhaocil.tech/2022/04/24/JS%E5%87%BD%E6%95%B0/"/>
    <id>http://zhaocil.tech/2022/04/24/JS%E5%87%BD%E6%95%B0/</id>
    <published>2022-04-24T02:07:45.000Z</published>
    <updated>2022-04-27T06:40:00.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="声明函数"><a href="#声明函数" class="headerlink" title="声明函数"></a>声明函数</h2><p>可以全局使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calcAge</span>(<span class="params">形参</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p>不能全局使用，得先定义才能使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calcAge = <span class="keyword">function</span> (<span class="params">形参</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>函数表达式，适合快速的单行功能，函数内只有一条表达式的情况下不需要使用 return 返回，箭头函数内的返回是隐式的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">calcAge</span> = (<span class="params">形参</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">//多行需要使用return</span></span><br><span class="line">  <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>函数通常以遇到的第一个 return 而结束</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h1&gt;&lt;h2 id=&quot;声明函数&quot;&gt;&lt;a href=&quot;#声明函数&quot; class=&quot;headerlink&quot; title=&quot;声明函数&quot;&gt;&lt;/a&gt;声明函数&lt;/h</summary>
      
    
    
    
    
    <category term="js" scheme="http://zhaocil.tech/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>jsonp</title>
    <link href="http://zhaocil.tech/2022/03/28/jsonp/"/>
    <id>http://zhaocil.tech/2022/03/28/jsonp/</id>
    <published>2022-03-28T08:30:04.000Z</published>
    <updated>2022-04-27T06:39:52.342Z</updated>
    
    
    
    
    
    <category term="js" scheme="http://zhaocil.tech/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>AJAX_1</title>
    <link href="http://zhaocil.tech/2022/03/25/AJAX-1/"/>
    <id>http://zhaocil.tech/2022/03/25/AJAX-1/</id>
    <published>2022-03-25T08:32:45.000Z</published>
    <updated>2022-04-27T06:39:31.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ajax-内部是咋写的"><a href="#ajax-内部是咋写的" class="headerlink" title="ajax 内部是咋写的"></a>ajax 内部是咋写的</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn1&quot;</span>);</span><br><span class="line">oBtn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//连接请求</span></span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;1.php?a=12&amp;b=5&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//发送请求</span></span><br><span class="line">  xhr.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//接收请求</span></span><br><span class="line">  xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//readyState的值表示目前通信处于什么状态</span></span><br><span class="line">    <span class="comment">//0初始化-刚刚创建</span></span><br><span class="line">    <span class="comment">//1以连接</span></span><br><span class="line">    <span class="comment">//2已发送</span></span><br><span class="line">    <span class="comment">//3已接收-头</span></span><br><span class="line">    <span class="comment">//4已接收-主体内容</span></span><br><span class="line">    <span class="title function_">alert</span>(xhr.<span class="property">readyState</span>);</span><br><span class="line">    <span class="comment">//不管请求成果或者失败，都会执行完4的内容</span></span><br><span class="line">    <span class="comment">//这时候需要用到http状态码了</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="http-状态码-status"><a href="#http-状态码-status" class="headerlink" title="http 状态码(status)"></a>http 状态码(status)</h2><p>游览器和服务器之间通过数字来表明状态,这个数字就是 http 状态码</p><p>1xx 消息</p><p>2xx 成功</p><p>3xx 重定向：原来的地址更改到了新的地址</p><p>​ 301：永久重定向-游览器不会再次请求老的地址</p><p>​ 302：临时重定向-游览器下次还会请求老地址</p><p>​ 304：缓存</p><p>4xx 请求错误（客户端）</p><p>5xx 服务端错误</p><p>6xx 拓展</p><p>所以，想要知道是否成功，就要看状态码是否是 2xx 或者 304</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt;= <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/../image/ajax/1.png" alt="image"></p><p>改成 1.php 就能成功了</p><p><img src="/../image/ajax/2.png" alt="image"></p><p>如果使用 post 请求，则需要添加一条额外的语句</p><p><img src="/../image/ajax/3.png" alt="image"></p><p>放在 open 和 send 之间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ajax-内部是咋写的&quot;&gt;&lt;a href=&quot;#ajax-内部是咋写的&quot; class=&quot;headerlink&quot; title=&quot;ajax 内部是咋写的&quot;&gt;&lt;/a&gt;ajax 内部是咋写的&lt;/h1&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;</summary>
      
    
    
    
    
    <category term="js" scheme="http://zhaocil.tech/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>async/await操作</title>
    <link href="http://zhaocil.tech/2022/03/24/async-await%E6%93%8D%E4%BD%9C/"/>
    <id>http://zhaocil.tech/2022/03/24/async-await%E6%93%8D%E4%BD%9C/</id>
    <published>2022-03-24T07:47:25.000Z</published>
    <updated>2022-04-27T06:39:38.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="async-x2F-await-操作"><a href="#async-x2F-await-操作" class="headerlink" title="async&#x2F;await 操作"></a>async&#x2F;await 操作</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">let</span> 结果=<span class="keyword">await</span> 异步操作-promise，generator，另一个<span class="keyword">async</span>函数</span><br><span class="line">    <span class="keyword">let</span> 结果=<span class="keyword">await</span> 异步操作-promise，generator，另一个<span class="keyword">async</span>函数</span><br><span class="line">    <span class="keyword">let</span> 结果=<span class="keyword">await</span> 异步操作-promise，generator，另一个<span class="keyword">async</span>函数</span><br><span class="line">    <span class="comment">//和generator用法类似,可以处理多个异步请求，可以不用前面的premise.all</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;async-x2F-await-操作&quot;&gt;&lt;a href=&quot;#async-x2F-await-操作&quot; class=&quot;headerlink&quot; title=&quot;async&amp;#x2F;await 操作&quot;&gt;&lt;/a&gt;async&amp;#x2F;await 操作&lt;/h2&gt;&lt;figure</summary>
      
    
    
    
    
    <category term="js" scheme="http://zhaocil.tech/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js_es6面向对象</title>
    <link href="http://zhaocil.tech/2022/03/23/js-es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://zhaocil.tech/2022/03/23/js-es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-03-23T07:36:50.000Z</published>
    <updated>2022-04-27T06:39:45.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="es6-面向对象"><a href="#es6-面向对象" class="headerlink" title="es6 面向对象"></a>es6 面向对象</h1><p>es6 的面向对象相对于传统 js 面向对象方便了很多</p><p>不需要用 function 来创建一个类</p><p>和 java 类似</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 对象名 &#123;</span><br><span class="line">  <span class="title class_">Constructor</span>() &#123;</span><br><span class="line">    这里写属性;</span><br><span class="line">  &#125;</span><br><span class="line">  这里写函数;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.png" alt="image"></p><h2 id="es6-的继承"><a href="#es6-的继承" class="headerlink" title="es6 的继承"></a>es6 的继承</h2><p>Es6 通过 super 来继承父类的属性</p><p>父类的方法通过 extends 来继承</p><p><img src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3.png" alt="image"></p><p><img src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2.png" alt="image"></p><h2 id="es6-面向对象的-this"><a href="#es6-面向对象的-this" class="headerlink" title="es6 面向对象的 this"></a>es6 面向对象的 this</h2><p>js 的 this 容易被改变，这里本来应该显示 blue 的，但 this 现在指向了 document</p><p><img src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4.png" alt="image"></p><p>修改的方法是在对象的方法后面，跟上一个 bind（blue）</p><p>这里修改成 blue.showName.bind(blue)</p><p>bind 是强制改变 this 的指向</p><p>bind 的可以修改 this 指向的对象</p><p>和 js 的 call 这个方法类似</p><h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h2><p>箭头函数：根据我所在的环境，环境是谁 this 就是谁</p><p><img src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5.png" alt="image"></p><p>这里别的实例对象用这个方法的时候，就不需要要用 bind 来改变指向了，这里 this 处在哪个环境，this 就是谁</p><p><img src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/6.png" alt="image"></p><p>普通函数：谁在调用 this，this 就是谁</p><p>上一节点击事件的错误就是因为是普通函数的缘故，this 指向了 document。</p><h2 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h2><p>拥有同步的简便，和异步的优点</p><p>有两个参数 resolve 和 reject</p><p>resolve：成功之后调用的函数</p><p>reject：失败之后调用的函数</p><p><img src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/7.png" alt="image"></p><p>promise 这个对象里面能执行一些方法和语句，执行完成后，resolve 和 reject 都会将括号里的值返回出去</p><p>promise 有局限性</p><ol><li>promise 有用-解除异步操作</li><li>有局限-带逻辑的异步操作很麻烦</li></ol><h3 id="promise"><a href="#promise" class="headerlink" title="promise-"></a>promise-</h3><p>promise-race(||的作用)</p><p>promise-all(&amp;&amp;的作用)</p><p>能获取多个地址的数据</p><p><img src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/8.png" alt="image"></p><p>Promise.all([pro 对象 1，pro 对象 2……]).then()</p><p>all 能获取 promise 的集合，可以用数组的形式将这三个对象存起来</p><p><img src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/9.png" alt="image"></p><p>因为 jQuery 的 Ajax 返回的对象里面，带有 Promise，所以这里 all 里面的对象可以直接用 jQuery 的 Ajax 表达式来使用</p><p><img src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/10.png" alt="image"></p><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>回调：有结果之后来找你</p><ol><li>不是定义的人调用</li><li>什么时候调用不知道</li></ol><p>轮询：一直询问</p><h2 id="generator-函数"><a href="#generator-函数" class="headerlink" title="generator 函数"></a>generator 函数</h2><p>Function *show(){}</p><p>函数名前面加一个*号</p><p>gen 函数与普通函数的区别是能暂停</p><p>并且用 yield 来分块</p><p><img src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/11.png" alt="image"></p><p>这儿已经被分成两块了</p><p>gen 函数直接使用不会生效，而是会产生一个返回值,这里将 show 这个对象给了 fan</p><p><img src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/12.png" alt="image"></p><p>要执行 show 里面的语句，需要用 next 这个方法来驱动</p><p>next 会在 yield 之前停下，如果要执行 yield 后面的语句，需要在调用一下 next 的方法</p><p>这样的好处是，有些异步操作需要时间，然后可以使用 yield 来分块，当异步操作执行完毕后，在执行后面的语句</p><p><img src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/13.png" alt="image"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;es6-面向对象&quot;&gt;&lt;a href=&quot;#es6-面向对象&quot; class=&quot;headerlink&quot; title=&quot;es6 面向对象&quot;&gt;&lt;/a&gt;es6 面向对象&lt;/h1&gt;&lt;p&gt;es6 的面向对象相对于传统 js 面向对象方便了很多&lt;/p&gt;
&lt;p&gt;不需要用 functi</summary>
      
    
    
    
    
    <category term="js" scheme="http://zhaocil.tech/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js面向对象</title>
    <link href="http://zhaocil.tech/2022/03/21/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://zhaocil.tech/2022/03/21/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-03-21T08:39:34.000Z</published>
    <updated>2022-04-27T06:40:13.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js-面向对象"><a href="#js-面向对象" class="headerlink" title="js 面向对象"></a>js 面向对象</h1><blockquote><p><a href="https://www.jianshu.com/p/f9792fdd9915">参考了该文章：JavaScript 面向对象 - 简书 (jianshu.com)</a></p></blockquote><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createCar(color,wheel)&#123;//createCar工厂</span><br><span class="line">    var obj = new Object;//或obj = &#123;&#125; 原材料阶段</span><br><span class="line">    obj.color = color;//加工</span><br><span class="line">    obj.wheel = wheel;//加工</span><br><span class="line">    return obj;//输出产品</span><br><span class="line">&#125;</span><br><span class="line">//实例化</span><br><span class="line">var cat1 = createCar(&quot;红色&quot;,&quot;4&quot;);</span><br><span class="line">var cat2 = createCar(&quot;蓝色&quot;,&quot;4&quot;);</span><br><span class="line"></span><br><span class="line">alert(cat1.color);//红色</span><br></pre></td></tr></table></figure><p>工厂模式对传入的值进行加工，然后输出</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><strong>构造函数就是类</strong></p><p>构造函数用于写属性</p><p><img src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.png" alt="image"></p><p>当我们 new 这个类的时候，这里的 name 和 sex 会作为属性一并被赋给 obj3</p><p><img src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2.png" alt="image"></p><p>我这儿构造函数的命名不规范，应该首字母大写</p><h2 id="原型（prototype）"><a href="#原型（prototype）" class="headerlink" title="原型（prototype）"></a>原型（prototype）</h2><p>*每个函数都有一个属性——****prototype**<strong>。这个*</strong>*prototype**<strong>的属性值是一个对象（属性的集合），默认只有一个叫做*</strong>*constructor****的属性，指向这个函数本身**</p><p><img src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3.png" alt="image"></p><p>这里是给 createPre 类，添加一个 showName 的方法，然后后面创建实例化对象（obj3）的时候，这个 obj3 会有这个方法</p><p><img src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4.png" alt="image"></p><h2 id="构造函数和原型的用法"><a href="#构造函数和原型的用法" class="headerlink" title="构造函数和原型的用法"></a>构造函数和原型的用法</h2><p>构造函数里面加属性，原型里面加方法</p><p><img src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5.png" alt="image"></p><p><strong>这里再放一张容易理解对象的图</strong></p><p><img src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/6.png" alt="image"></p><p><img src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/7.png" alt="image"></p><p>这里的不同颜色的车和不同种类的狗，就是 new 出来的实例对象</p><h2 id="命令空间"><a href="#命令空间" class="headerlink" title="命令空间"></a>命令空间</h2><p><img src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/8.png" alt="image"></p><p>不同对象，相同方法</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>js 通过 call 方法来继承父元素的属性</p><p>call 方法：可以改变函数执行的时候，里面的 this</p><p><img src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/9.png" alt="image"></p><p>call 可以传参数，这里的 this 就是 show2 这个对象</p><p>call 将 show2 这个对象传入 show</p><p>然后将 show 里面 this 指向指为 show2</p><h3 id="继承的问题"><a href="#继承的问题" class="headerlink" title="继承的问题"></a>继承的问题</h3><p>这里举个栗子</p><p><img src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/10.png" alt="image"></p><p>这里 arr2 并不是复制了一份 arr1，而是将 arr2 也指向了 arr1 的空间了</p><p>他们都指向了同一块空间</p><p><img src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/14.png" alt="image"></p><p>可以看见这个 arr1 里面的数据也被更改了</p><p>解决这个问题的方法是，用循环将 arr1 里面的数据传入 arr2</p><p><img src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/11.png" alt="image"></p><p>对象里面，方法的继承也存在同样的问题</p><p><img src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/13.png" alt="image"></p><p>这样做的话，会和上面数组的问题一样，修改 show2 的方法，show 的方法也会被修改</p><p><img src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/12.png" alt="image"></p><p>这样就不会出问题了</p><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p><img src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/15.png" alt="image"></p><p>重写就是将新的原型里面的方法，给重新写一遍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;js-面向对象&quot;&gt;&lt;a href=&quot;#js-面向对象&quot; class=&quot;headerlink&quot; title=&quot;js 面向对象&quot;&gt;&lt;/a&gt;js 面向对象&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/f9</summary>
      
    
    
    
    
    <category term="js" scheme="http://zhaocil.tech/tags/js/"/>
    
  </entry>
  
</feed>
