<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>对象与对象</title>
    <link href="/2023/07/28/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/07/28/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="对象与对象"><a href="#对象与对象" class="headerlink" title="对象与对象"></a>对象与对象</h1><h2 id="对象里面添加一个对象作为属性"><a href="#对象里面添加一个对象作为属性" class="headerlink" title="对象里面添加一个对象作为属性"></a>对象里面添加一个对象作为属性</h2><p>一个学生类里面，添加一个电脑类，作为它的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">学生类<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> comper cer; <span class="hljs-comment">//电脑类</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">电脑类<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">comper</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> String cpu;<br>    <span class="hljs-keyword">public</span> String gpu;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用的话，就和普通变量一样使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">comper</span> <span class="hljs-variable">cper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">comper</span>();<br>cper.cpu = <span class="hljs-string">&quot;酷睿&quot;</span>;<br><br><span class="hljs-type">student</span> <span class="hljs-variable">stud</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">student</span>();<br>stud.cer = cper; <span class="hljs-comment">// 将上面的电脑类作为值赋给学生类的属性(cer)</span><br></code></pre></td></tr></table></figure><p>调用就是stud.cer.cpu。这个还是好理解的</p><h2 id="将对象数组作为对象的属性"><a href="#将对象数组作为对象的属性" class="headerlink" title="将对象数组作为对象的属性"></a>将对象数组作为对象的属性</h2><p>是不是听起来听拗口的</p><p>写出来还是好理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">comper</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> String cpu;<br>    <span class="hljs-keyword">public</span> String gpu;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">comper</span><span class="hljs-params">(String name, String cpu, String gpu)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.cpu = cpu;<br>        <span class="hljs-built_in">this</span>.gpu = gpu;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将上面的学生类拿过来用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">学生类<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> comper[] cer; <span class="hljs-comment">//用数组存储多个电脑类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里cer使用起来和前面的对象数组的效果是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">student</span> <span class="hljs-variable">stud</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">student</span>();<br>        stud.cer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">comper</span>[]&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">comper</span>(<span class="hljs-string">&quot;n1&quot;</span>, <span class="hljs-string">&quot;zhang@email.com&quot;</span>, <span class="hljs-string">&quot;x&quot;</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">comper</span>(<span class="hljs-string">&quot;n2&quot;</span>, <span class="hljs-string">&quot;zhang@email.com&quot;</span>, <span class="hljs-string">&quot;y&quot;</span>)<br>        &#125;;<br>        System.out.println(stud.cer[<span class="hljs-number">0</span>].name);<span class="hljs-comment">//n1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态字段和静态方法(static)</title>
    <link href="/2023/07/24/%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-static/"/>
    <url>/2023/07/24/%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-static/</url>
    
    <content type="html"><![CDATA[<h1 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h1>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合</title>
    <link href="/2022/08/12/%E9%9B%86%E5%90%88/"/>
    <url>/2022/08/12/%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>这里只介绍常用的一些集合及方法</p><p>存储数据的容器</p><p>可以存储多种类型的数据，可以随着集合的大小动态增加和缩小</p><h1 id="集合的分类"><a href="#集合的分类" class="headerlink" title="集合的分类"></a>集合的分类</h1><p><img src="/.io//Users\zzz\Desktop\blog\source_posts\集合\集合分类.png"></p><h1 id="定义集合的方式"><a href="#定义集合的方式" class="headerlink" title="定义集合的方式"></a>定义集合的方式</h1><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Collection collection <span class="hljs-operator">=</span> new ArraList()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ArrayList&lt;泛型&gt; list <span class="hljs-operator">=</span> new ArrayList()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h1 id="ArrayList-lt-泛型-gt"><a href="#ArrayList-lt-泛型-gt" class="headerlink" title="ArrayList&lt;泛型&gt;"></a>ArrayList&lt;泛型&gt;</h1><p>常用的方法</p><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>向集合里面添加数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;数据类型&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Arraylist</span>();<br>list.add(数据);<br></code></pre></td></tr></table></figure><h2 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h2><p>判断集合是否为空，返回布尔类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">list.isEmpty()<br></code></pre></td></tr></table></figure><h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>移除元素，如果参数为对象，则返回布尔类型，如果参数为下标或者索引，返回值则为删除的元素</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list.<span class="hljs-built_in">remove</span>(参数)<br></code></pre></td></tr></table></figure><h2 id="addAll"><a href="#addAll" class="headerlink" title="addAll"></a>addAll</h2><p>添加多个元素，返回值为boolean，参数为一个集合，将集合展开添加至list，如果使用add添加集合，add会将一整个集合当作一个元素添加进去.</p><p>参数1为添加的位置，参数2为要添加的集合</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">list</span>.addAll(参数<span class="hljs-number">1</span>，参数<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>根据index的值来修改指定位置的对象为参数，返回值为修改之前的对象</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">list.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">index</span>,参数);<br></code></pre></td></tr></table></figure><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>根据index来查找对象</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi">list.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">index</span>)<br></code></pre></td></tr></table></figure><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p>根据对象查找该索引</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">list.<span class="hljs-built_in">indexOf</span>(参数)<br></code></pre></td></tr></table></figure><h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>返回集合的长度</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran">list.<span class="hljs-built_in">size</span>()<br></code></pre></td></tr></table></figure><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="HasMap"><a href="#HasMap" class="headerlink" title="HasMap"></a>HasMap</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs lsl">HashMap&lt;String, Object&gt; <span class="hljs-type">list</span> = new HashMap&lt;&gt;();<br>        <span class="hljs-type">list</span>.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>);<br>        <span class="hljs-type">list</span>.put(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);<br>        <span class="hljs-type">list</span>.put(<span class="hljs-string">&quot;name2&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>);<br>        <span class="hljs-type">list</span>.put(<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);<br>        <span class="hljs-type">list</span>.put(<span class="hljs-string">&quot;jack2&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>);<br>        <span class="hljs-type">list</span>.put(<span class="hljs-string">&quot;jack3&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);<br>        <span class="hljs-type">list</span>.put(<span class="hljs-string">&quot;jack4&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>);<br>        <span class="hljs-type">list</span>.put(<span class="hljs-string">&quot;jack5&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);<br><br><span class="hljs-comment">//        返回对应key的value，如果key不存在，则返回默认值</span><br>        System.out.println(<span class="hljs-string">&quot;getOrDefault返回对应的key<span class="hljs-subst">\t</span><span class="hljs-subst">\t</span>&quot;</span>+<span class="hljs-type">list</span>.getOrDefault(<span class="hljs-string">&quot;javase&quot;</span>, <span class="hljs-string">&quot;javasm&quot;</span>));<br><span class="hljs-comment">//        添加数据，如果该key存在，则不添加，如果不存在，则添加</span><br>        <span class="hljs-type">list</span>.putIfAbsent(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;java&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;putIfAbsent添加数据<span class="hljs-subst">\t</span><span class="hljs-subst">\t</span>&quot;</span>+<span class="hljs-type">list</span>);<br>        <br><span class="hljs-comment">//        根据键值对进行删除操作，键值对与map里面的键值对匹配才会删除</span><br>        <span class="hljs-type">list</span>.remove(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;remove删除数据<span class="hljs-subst">\t</span><span class="hljs-subst">\t</span>&quot;</span>+<span class="hljs-type">list</span>);<br>        <br><span class="hljs-comment">//        替换操作，根据对应的key去替换value</span><br>        <span class="hljs-type">list</span>.replace(<span class="hljs-string">&quot;name2&quot;</span>, <span class="hljs-string">&quot;jack&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;replace替换<span class="hljs-subst">\t</span><span class="hljs-subst">\t</span>&quot;</span>+<span class="hljs-type">list</span>);<br>        <br><span class="hljs-comment">//        通过匹配键值对，来对其进行替换</span><br>        <span class="hljs-type">list</span>.replace(<span class="hljs-string">&quot;jack3&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;replace匹配键值对<span class="hljs-subst">\t</span><span class="hljs-subst">\t</span>&quot;</span>+<span class="hljs-type">list</span>);<br></code></pre></td></tr></table></figure><p><img src="/.io//Users\zzz\Desktop\blog\source_posts\集合\HashMap.png"></p><p>定义的方式</p><p>HashMap&lt;键的类型，值的类型&gt;</p><p>键值的类型可以是任意类型</p><h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java异常</title>
    <link href="/2022/08/07/java%E5%BC%82%E5%B8%B8/"/>
    <url>/2022/08/07/java%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h1><p>我们在编写程序的时候，难免会出现Bug，这些bug就是异常。这些异常的发生往往会中断程序的运行。</p><h1 id="异常的分类-Exception"><a href="#异常的分类-Exception" class="headerlink" title="异常的分类(Exception)"></a>异常的分类(Exception)</h1><h2 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h2><p>在编译器编辑的时候就发现的异常，通常编译器会会报红</p><p><img src="/.io//Users\zzz\Desktop\blog\source_posts\java异常\编译时异常.png"></p><ol><li>这种也称之为可检测的异常</li><li>必须要处理</li></ol><h2 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h2><ol><li>编译可以正常的通过，但是运行会报错。比如：空指针异常，数组下标越界等等…..</li><li>这种也称之为未检测的异常，不一定会触发</li><li>可处理也可以不用处理</li></ol><h1 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h1><h2 id="积极处理：捕捉异常"><a href="#积极处理：捕捉异常" class="headerlink" title="积极处理：捕捉异常"></a>积极处理：捕捉异常</h2><h3 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h3><p>语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    要进行捕捉错误的代码，可能会出现异常的代码<br>&#125;<span class="hljs-keyword">catch</span>(异常种类 对象名)&#123;<br>    处理方式<br>&#125;<br></code></pre></td></tr></table></figure><p>try和catch不能单独使用</p><p>选择异常种类时，尽量明确异常的种类，少使用exception</p><p>未使用捕捉</p><p><img src="/.io//Users\zzz\Desktop\blog\source_posts\java异常\强制结束程序.png"></p><p>使用捕捉</p><p><img src="/.io//Users\zzz\Desktop\blog\source_posts\java异常\捕捉异常.png"></p><h3 id="try…catch…catch"><a href="#try…catch…catch" class="headerlink" title="try…catch…catch"></a>try…catch…catch</h3><p>捕捉多个异常，因为一个try可能会不止一个异常，这时候需要多个catch进行解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <br>&#125;<span class="hljs-keyword">catch</span>()&#123;<br>    <br>&#125;<span class="hljs-keyword">catch</span>()&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>像else if一样，异常会根据catch()括号里面的异常类型来选择进入哪个catch。</p><p>要注意一个点，父类异常类如果在第一个catch，那么子类异常类就不能往后写了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>    <br>&#125;<span class="hljs-keyword">catch</span>(a e)&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>因为Exception是a的父类，exception包含了a的异常类，所以异常发生的时候，会先进入父类，会造成子类完全访问不到</p><h3 id="try…catch…finally"><a href="#try…catch…finally" class="headerlink" title="try…catch…finally"></a>try…catch…finally</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>    <br>&#125;<span class="hljs-keyword">catch</span>()&#123;<br>    <br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>try无论捉没捉到异常，finally里面的语句都会被执行</p><h3 id="try…-with…-resources-自动回收"><a href="#try…-with…-resources-自动回收" class="headerlink" title="try….with….resources(自动回收)"></a>try….with….resources(自动回收)</h3><p>一般像普通程序捕捉异常，会手动回收异常类，调用close方法</p><p>如果用了resources语法，则可以不用手动回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(需要回收的对象)&#123;<br>    <br>&#125;<span class="hljs-keyword">catch</span>()&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="消极处理"><a href="#消极处理" class="headerlink" title="消极处理"></a>消极处理</h2><p>通过throw来将异常抛出，谁调用谁处理</p><p><img src="/.io//Users\zzz\Desktop\blog\source_posts\java异常\消极处理.png"></p><p>如果抛出的是RuntimeException异常类，则可以处理也可以不处理</p><blockquote><p>尽量使用积极处理</p></blockquote><h2 id="throw和throws"><a href="#throw和throws" class="headerlink" title="throw和throws"></a>throw和throws</h2><p>throw new 异常类</p><ol><li>throws用在函数声明上，后面可以跟多个异常类，用逗号隔开</li><li>throw后跟的是异常对象</li></ol><p>throw如果手动引发一个编译时的异常，那么该异常就一定要处理！</p><p>如果是引发的一个运行时的异常，那么该异常可处理也可以不用处理</p><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>除了使用系统自带的异常规则，我们也可以自己去建立异常规则。</p><p>比如系统计算数学，0不能作为除数，而我们想加一条规则，负数不能作为除数，这个时候就要用到自定义异常了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> extends 异常类&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyException</span><span class="hljs-params">(String message)</span>&#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">show</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">throws</span> MyException &#123;<span class="hljs-comment">//方法将错误接着抛出,调用该方法的地方需要用try进行捕捉异常</span><br>       <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyException</span>(<span class="hljs-string">&quot;除数不能为负数&quot;</span>); <span class="hljs-comment">//将错误抛出</span><br>        &#125;<br>     <span class="hljs-keyword">return</span> a / b;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/.io//Users\zzz\Desktop\blog\source_posts\java异常\自定义异常.png"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深拷贝和浅拷贝</title>
    <link href="/2022/08/04/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2022/08/04/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="Java中拷贝问题"><a href="#Java中拷贝问题" class="headerlink" title="Java中拷贝问题"></a>Java中拷贝问题</h1><p>除了String类型，其他的引用类型在使用&#x3D;号赋值的时候，会将地址传给&#x3D;号左侧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br><span class="hljs-type">User</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;<br><span class="hljs-comment">//这里的b其实是获得了a的地址，后面继续操作b的话，相当于操作a</span><br></code></pre></td></tr></table></figure><p>要解决这样的问题就需要用到浅拷贝和深拷贝了</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>实体类实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">// Cloneable标记此类可以进行克隆操作，没有其他实际意义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <br>    <span class="hljs-comment">//重写clone方法</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException&#123;<br>         <span class="hljs-keyword">return</span> (User)<span class="hljs-built_in">super</span>.clone;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>浅拷贝有缺点，就是当类中有数组或者其他类成员的时候，还是会出现赋值地址的问题，所以就需要用到深拷贝</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br>    <span class="hljs-keyword">private</span> User2 user2;<br>    <span class="hljs-keyword">private</span> String[] hobby;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候浅拷贝是解决不了这个问题的</p><p>对象有两种解决方案</p><ol><li><p>new新的对象，然后赋值给user2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-type">User2</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User2</span>(clone.getUser().属性,属性<span class="hljs-number">2.</span>...);<br>clone.setUser2(user2);<br></code></pre></td></tr></table></figure></li><li><p>在成员类里面先进行浅拷贝，然后再将返回的对象赋值给成员类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <br>     <span class="hljs-keyword">public</span> User2 <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException&#123;<br>         <span class="hljs-keyword">return</span> (User2)<span class="hljs-built_in">super</span>.clone;  <br>    &#125;<br>    <br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;    <br>    <span class="hljs-keyword">private</span> User2 user2;    <br>    <span class="hljs-keyword">private</span> String[] hobby;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">clone</span> <span class="hljs-operator">=</span> (User) <span class="hljs-built_in">super</span>.clone();<br>    <br>    <span class="hljs-type">User2</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> clone.getUser2().clone();<br>    clone.setUser2(user2);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="数组要容易些"><a href="#数组要容易些" class="headerlink" title="数组要容易些"></a>数组要容易些</h2><p>直接用copyOf对原数组进行覆盖即可</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2022/08/04/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/08/04/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h1><ul><li>最简单的设计模式之一</li><li>单个实例&#x2F;单个对象，最终只会产生一个对象</li></ul><h1 id="实现单例模式的方式"><a href="#实现单例模式的方式" class="headerlink" title="实现单例模式的方式"></a>实现单例模式的方式</h1><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><ul><li>将构造方法私有化    -&gt;设置为private，不对外开放</li><li>在类的内部去创建对象</li><li>添加一个对外的方法，通过这个方法去创建实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> User user;<br>    <br>    <span class="hljs-comment">//将构造函数私有化,这样就使得外面new对象的时候无法成功</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-comment">//提供创建对象的方法</span><br>    <span class="hljs-comment">//synchronized：锁,用来保证线程安全，但是会造成执行效率比较低</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//如果已经创建了对象，则之间返回，否则创建新对象</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.user == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-built_in">this</span>.user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><ul><li>及时加载，无论对象是否使用，都会创建一个</li><li>构造方法私有化</li><li>直接创建对象</li><li>对外提供方法，提供唯一对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    <br>    <span class="hljs-comment">//将构造函数私有化,这样就使得外面new对象的时候无法成功</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span>&#123;&#125;<br>    <br>    <span class="hljs-comment">//提供创建对象的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>优点是保证线程安全，缺陷是会造成资源的浪费，因为无论用不用该对象，该对象都会被创建</p><blockquote><p>暂时学了这么多，等待后续更新</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象数组</title>
    <link href="/2022/07/28/%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84/"/>
    <url>/2022/07/28/%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h1><p>字面意思来说就是一个类型为对象的数组，然后这个数组里面每一个元素都是实例对象</p><p>java用的还是不太熟，这里用js的对象数组来理解就方便些</p><h2 id="js和java对象数组比较"><a href="#js和java对象数组比较" class="headerlink" title="js和java对象数组比较"></a>js和java对象数组比较</h2><h3 id="JS定义对象数组"><a href="#JS定义对象数组" class="headerlink" title="JS定义对象数组"></a>JS定义对象数组</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">data = [<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;n1&quot;</span>, <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;zhang@email.com&quot;</span>&#125;,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;n2&quot;</span>,   <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;jiang@email.com&quot;</span>&#125;<br>];<br></code></pre></td></tr></table></figure><h3 id="java定义对象数组"><a href="#java定义对象数组" class="headerlink" title="java定义对象数组"></a>java定义对象数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">car[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">car</span>[]&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">car</span>(<span class="hljs-string">&quot;n1&quot;</span>, <span class="hljs-string">&quot;zhang@email.com&quot;</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">car</span>(<span class="hljs-string">&quot;n2&quot;</span>, <span class="hljs-string">&quot;zhang@email.com&quot;</span>)<br>&#125;;<br></code></pre></td></tr></table></figure><p>两者定义的区别还是很明显的，但是作用没太大差别</p><h3 id="JS对象数组取数据"><a href="#JS对象数组取数据" class="headerlink" title="JS对象数组取数据"></a>JS对象数组取数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">data[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>;<br></code></pre></td></tr></table></figure><h3 id="Java对象数组取数据"><a href="#Java对象数组取数据" class="headerlink" title="Java对象数组取数据"></a>Java对象数组取数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">data[<span class="hljs-number">0</span>]name<br></code></pre></td></tr></table></figure><p>取数据倒是没啥差别</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多态，抽象，接口</title>
    <link href="/2022/07/24/%E5%A4%9A%E6%80%81%EF%BC%8C%E6%8A%BD%E8%B1%A1%EF%BC%8C%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/07/24/%E5%A4%9A%E6%80%81%EF%BC%8C%E6%8A%BD%E8%B1%A1%EF%BC%8C%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ol><li>多态的弊端，不能使用子类特有的内容</li><li>多态前提<ol><li>必须要有关系，继承，实现</li><li>必须要有重写</li></ol></li></ol><h3 id="多态向上转型"><a href="#多态向上转型" class="headerlink" title="多态向上转型"></a>多态向上转型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">有一个动物类Animal,子类猫cat<br><span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>()<br></code></pre></td></tr></table></figure><p>这什么意思呢，看看基本属性类型的强转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> x <span class="hljs-comment">//这里x会自动提升为int</span><br></code></pre></td></tr></table></figure><p><strong>可以把上面的Animal看作int，cat看作byte，所以这里新new出来的猫类，会自动提升为动物类</strong></p><p>提升成动物类之后，只能用动物类里面的方法和自己类里面重写的方法，但是不能使用猫类自己特有的方法了</p><p>可以限制功能使用，提高拓展性</p><h3 id="多态向下转型"><a href="#多态向下转型" class="headerlink" title="多态向下转型"></a>多态向下转型</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Cat c <span class="hljs-operator">=</span> (Cat) a<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>将动物类的a，强转为猫类，然后赋给c，因为动物类是父类，所以这里强转为猫类就是向下转型</strong></p><p>向下转型就可以使用子类特有的方法了</p><h3 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br><span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (Cat)a; <br><span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">dog</span>();<br><span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (Cat)a; <br></code></pre></td></tr></table></figure><p>上面两种操作都是不行的</p><ol><li>不能将父类强转为子类，上面能转，是因为其本身new的就是猫类，所以可以强转回来</li><li>两个毫不相关的类也不能转，猫可以是动物，也可以是猫，但是狗只能是狗，不能叫它猫</li><li>小可以转大，但大不能转小</li></ol><h3 id="判断是否为正确的对象"><a href="#判断是否为正确的对象" class="headerlink" title="判断是否为正确的对象"></a>判断是否为正确的对象</h3><p>a instanceof Cat：判断a是否为Cat类型的对象</p><p>instanceof 只能用于引用数据类型的判断 </p><h3 id="多态中的成员变量"><a href="#多态中的成员变量" class="headerlink" title="多态中的成员变量"></a>多态中的成员变量</h3><p>参考引用型变量所属的类中，是否有调用的成员变量，有就通过，没有就失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">fu</span>()&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">fu</span>()&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">fu</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">zi</span>();<br>System.ou.println(f.num); <span class="hljs-comment">//4</span><br></code></pre></td></tr></table></figure><p>引用类型为哪个类，直接调用时，就会访问到哪个类里面的成员变量</p><p>编译和运行时，参考等号的左边</p><h3 id="多态中的成员方法"><a href="#多态中的成员方法" class="headerlink" title="多态中的成员方法"></a>多态中的成员方法</h3><p>自动类型提升了，就隐藏了子类特有的方法</p><p>编译看左边，运行看右边，动态绑定，谁调用就绑定谁</p><h3 id="多态中的静态方法"><a href="#多态中的静态方法" class="headerlink" title="多态中的静态方法"></a>多态中的静态方法</h3><p>静态方法在类生成的时候就绑定了，并不具备多态性</p><p>多态是基于对象的，静态方法是基于类的     </p><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>子类里面定义了一个和父类里一个相同的方法，则叫重写</p><p>可以理解子类从父类那儿复制了一个方法，子类修改这个方法的时候，父类不会受影响</p><h3 id="决定重写的因素"><a href="#决定重写的因素" class="headerlink" title="决定重写的因素"></a>决定重写的因素</h3><ol><li>子类与父类之间</li><li>方法名和参数必须都相同</li></ol><h3 id="重写系统方法"><a href="#重写系统方法" class="headerlink" title="重写系统方法"></a>重写系统方法</h3><p>因为Object是所有类的祖类，所以在自定义类中，是可以重写系统方法的</p><h2 id="一些小细节"><a href="#一些小细节" class="headerlink" title="一些小细节"></a>一些小细节</h2><p><img src="https://pic.imgdb.cn/item/64cbad781ddac507cc675f53.jpg"></p><p>子类返回值类型和父类的返回值类型存在一个继承关系，则可以设定为不一样的返回值类型</p><p><img src="https://pic.imgdb.cn/item/64cbae371ddac507cc6961f9.jpg"></p><p>访问修饰符也差不多意思，父类的修饰符只要大于子类的范围，子类就可以设定其他的修饰符</p><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>如果一个<code>class</code>定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用<code>abstract</code>修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> class 类名&#123;&#125;<br></code></pre></td></tr></table></figure><p>如果父类本身的方法不需要实现任何功能，仅仅是为了定义方法格式，目的是让子类去重写它，那么，就可以把父类声明为抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">class 类名&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//会报错</span><br></code></pre></td></tr></table></figure><p>包含抽象方法的父类，父类必须也为抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">abstrract class 类名&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象类本身是不能被实例化的，所以只能被用于继承</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>当一个抽象类中的方法都是抽象的时候，这时候就可以用接口来表示</p><p>接口里面定义方法，里面定义的方法默认都是public abstract，所以修饰符都不用写出来</p><p>用interface来声明一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">interface 类名&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> 类型 变量名;<span class="hljs-comment">//定义全局常量</span><br>    返回值类型 方法名();<br>&#125;<br></code></pre></td></tr></table></figure><p>接口中的成员都是公共的权限</p><p>类与类是继承关系，<strong>类与接口是实现关系</strong>，接口不可以实例化 </p><h2 id="子类实现接口"><a href="#子类实现接口" class="headerlink" title="子类实现接口"></a>子类实现接口</h2><p>子类实现接口时，需要用到implements关键，和普通继承不一样的是，子类可以选择实现多个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">class 子类名 implements 接口<span class="hljs-number">1</span>，接口<span class="hljs-number">2</span>，接口<span class="hljs-number">3.</span>...&#123;&#125;<br></code></pre></td></tr></table></figure><p>不要在多个接口里面，定义相同方法名的方法</p><p>一个类是可以继承一个父类，实现多个接口的</p><h2 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h2><p>接口可以通过extends关键字继承其他接口，可以多继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">interface  接口<span class="hljs-number">1</span> extends 接口<span class="hljs-number">2</span>, 接口<span class="hljs-number">3</span>, 接口<span class="hljs-number">4.</span>...<br></code></pre></td></tr></table></figure><h2 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h2><p>在接口中，也可以用default来修饰一个方法，被修饰的方法，子类在继承接口的时候，可以选择是否重写这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">interface 类名&#123;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>    String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>没被default所修饰的方法，子类里面必须要重写一遍的</p></blockquote><p>default可以避免接口新增一个方法时，下面的子类都得重写</p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">(参数)-&gt;&#123;<br>    方法体<br>&#125;<br></code></pre></td></tr></table></figure><p>和js的箭头函数类似，实质上是一种简化过程，多用于函数式接口</p><h4 id="lambda能省略的情况"><a href="#lambda能省略的情况" class="headerlink" title="lambda能省略的情况"></a>lambda能省略的情况</h4><p>​        ①、省略形参()：当形参的个数有且只有1个的时候，同时省略形参的数据类型！<br>​            ②、省略{}：当方法体中有且只有一行代码的时候省略！<br>​            ③、省略形参的数据类型：当省略形参的数据类型将全部参数的类型都省略！<br>​            ④、省略return：当方法体中只有一个返回值的之后。省略return，但是要将{}一并省略！</p><h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><p><img src="https://pic.imgdb.cn/item/64be7a011ddac507cce99a25.jpg"></p><blockquote><p>多数参考廖雪峰老师的java教程</p></blockquote><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><table><thead><tr><th>访问修饰符</th><th>同类中</th><th>同package中</th><th>不同package中</th><th>子类与父类之间（不在同一个包）</th></tr></thead><tbody><tr><td>private：私有的</td><td>允许</td><td>不允许</td><td>不允许</td><td>不允许</td></tr><tr><td>缺省：家庭权限</td><td>允许</td><td>允许</td><td>不允许</td><td>不允许</td></tr><tr><td>protected：家族权限</td><td>允许</td><td>允许</td><td>不允许</td><td>？？？</td></tr><tr><td>public公共的</td><td>允许</td><td>允许</td><td>允许</td><td>允许</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承</title>
    <link href="/2022/07/23/%E7%BB%A7%E6%89%BF/"/>
    <url>/2022/07/23/%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>我们定义了两个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    String name;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person2</span>&#123;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有很多重复代码，这是没必要的。这时候可以用上继承这个特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;&#125;<br><span class="hljs-type">Person2</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person2</span>();<br>   pre.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br>   pre.getName();<span class="hljs-comment">//张三</span><br></code></pre></td></tr></table></figure><p><img src="https://pic.imgdb.cn/item/64bd21f31ddac507ccb7a3ca.jpg"></p><p>可以看到，我们第二个类都没声明任何东西，就可以使用父类的方法以及属性</p><p>通过关键字extends可以使子类继承父类的方法和属性</p><p><strong>class 子类名 extends 父类名{}</strong></p><h2 id="无法被访问的字段"><a href="#无法被访问的字段" class="headerlink" title="无法被访问的字段"></a>无法被访问的字段</h2><p>如果父类里面有<strong>private</strong>所修饰的字段，子类是无法访问和使用的</p><p>这个时候改用protected来修饰字段就可以了。</p><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>子类在继承父类的时候，子类不会继承父类的构造方法，用super可以解决这个问题</p><p>父类如果没有定义无参的构造函数，子类定义自己的构造函数时，会报错</p><p><img src="https://pic.imgdb.cn/item/64bdd8901ddac507cc1ef994.jpg"></p><p>因为构造方法，如果没有明确的调用父类的构造方法，编译器隐式的加上super(),可是我们这里父类并没有定义无参的构造方法，所以就造成了错误</p><p>super更像是子类与父类的接口，这里解决方案就是super(a,b)</p><h3 id="还是有个问题"><a href="#还是有个问题" class="headerlink" title="还是有个问题"></a>还是有个问题</h3><p>如果我需要在子类的构造方法中去初始化子类自己的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person2</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-comment">//这里系统会自动加上super()</span><br>        <span class="hljs-built_in">this</span>.age = age;<br>        System.out.println(<span class="hljs-built_in">this</span>.age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是又不想去初始化从父类继承过来的那个变量，这里不用super就会报错。</p><p>最优解还是父类定义一个无参的构造方法，最方便。</p><h2 id="不想被继承的类"><a href="#不想被继承的类" class="headerlink" title="不想被继承的类"></a>不想被继承的类</h2><p>final这个功能很强大，不仅是将变量变成常量，而且还能修饰别的</p><p>类，方法，字段如果被final修饰了，则不能被其他子类所继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;&#125; <span class="hljs-comment">//不让被继承的方法</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;&#125; <span class="hljs-comment">//不让被继承的类</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Unamed&quot;</span>;<span class="hljs-comment">//不让被继承的属性</span><br></code></pre></td></tr></table></figure><blockquote><p>可以在构造函数里面初始化被final修饰的字段</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java方法</title>
    <link href="/2022/07/21/java-%E6%96%B9%E6%B3%95/"/>
    <url>/2022/07/21/java-%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="java-方法"><a href="#java-方法" class="headerlink" title="java 方法"></a>java 方法</h1><h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">修饰符 方法返回类型 方法名(参数列表&#125;&#123;<br>    代码块<br>    <span class="hljs-keyword">return</span> 返回值<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有返回值，返回值类型可以设置为 void</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>在类中定义一个和类名一致的方法名，不需要写返回类型</p><ul><li><p>无参构造方法，每个类中都会默认存在一个，当你定义了一个构造方法时，这个默认的就会失效</p><p>class Preson(){​</p><p>​    public Preeson(){}</p><p>}</p></li><li><p>有参构造方法</p><p>class Preson(参数1，参数2….){</p><p>​    public Preeson(){}</p><p>}</p><p><strong>构造方法一般用于实例化对象的初始化</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span>&#123;&#125;<br>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">double</span> b)</span>&#123;&#125;<br>  &#125;<br>  <br>  <span class="hljs-type">Person</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">50</span>,<span class="hljs-number">25.3</span>)<br>      <span class="hljs-comment">//因为我们定义一个无参和一个有参的构造方法，所以实例化的时候写参数和不写参数都可以</span><br></code></pre></td></tr></table></figure><blockquote><p>构造方法也是可以重载的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数</title>
    <link href="/2022/05/16/%E5%87%BD%E6%95%B0/"/>
    <url>/2022/05/16/%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数默认值"><a href="#函数默认值" class="headerlink" title="函数默认值"></a>函数默认值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// es5</span><br><span class="hljs-keyword">const</span> show = <span class="hljs-keyword">function</span> (<span class="hljs-params">one</span>) &#123;<br>  one = one || <span class="hljs-number">5</span>;<br>&#125;;<br><span class="hljs-comment">// es6</span><br><span class="hljs-keyword">const</span> show = <span class="hljs-keyword">function</span> (<span class="hljs-params">one = <span class="hljs-number">5</span></span>) &#123;&#125;;<br><span class="hljs-comment">// one此时默认值就为5</span><br>传参的时候如果不想输入，而直接使用默认值，则传过去一个<span class="hljs-literal">undefined</span>就可以<br></code></pre></td></tr></table></figure><h2 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h2><p>如果函数的接受参数是一个复合对象</p><p>则这个参数会指向那个对象的地址</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;男&quot;</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> show = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj2</span>) &#123;<br>  obj2.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;李四&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>此时 obj 的 name 也被修改成李四了;</p><p>和这个情况是一样的;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;男&quot;</span>,<br>&#125;;<br><br><span class="hljs-keyword">let</span> obj2 = obj;<br><br>obj2.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;李四&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://s1.328888.xyz/2022/05/16/qMDnM.png" alt="qMDnM.png"></p><p>函数也是对象</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> one = <span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">toUpperCase</span>();<br>&#125;;<br><br><span class="hljs-keyword">const</span> two = <span class="hljs-keyword">function</span> (<span class="hljs-params">str, fn</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(str));<br>&#125;;<br><br><span class="hljs-title function_">two</span>(<span class="hljs-string">&quot;agecdfg&quot;</span>, one);<br></code></pre></td></tr></table></figure><p><img src="https://s1.328888.xyz/2022/05/18/D0XEg.png" alt="D0XEg.png"></p><p>如果当作事件来看，会好理解很多</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;&#125;);<br><span class="hljs-comment">//本身add...就是一个方法（也可以称为函数），第二个参数就是要实现的函数</span><br></code></pre></td></tr></table></figure><p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。</p><p>在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包让你可以在一个内层函数中访问到其外层函数的作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> greet = <span class="hljs-keyword">function</span> (<span class="hljs-params">string</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(string, name);<br>  &#125;;<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">greet</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br><span class="hljs-title function_">greet</span>(<span class="hljs-string">&quot;Hello&quot;</span>)(<span class="hljs-string">&quot;小王&quot;</span>);<br><span class="hljs-title function_">greet2</span>(<span class="hljs-string">&quot;小王&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://s1.328888.xyz/2022/05/19/D3Hik.png" alt="D3Hik.png"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>闭包让你可以在一个内层函数中访问到其外层函数的作用域闭包让你可以在一个内层函数中访问到其外层函数的作用域</p><p>闭包是封闭变量，执行上下文的环境，在其中创建了一个函数,即使在那个执行上下文消失之后（即使在函数之后），执行上下文所属的已经返回</p><p>闭包使函数可以访问所有变量，其父函数</p><p>所以函数保持对其外部范围的引用，即使在那个外部范围消失之后，这基本上保留了整个时间范围链</p><h3 id="另一个定义"><a href="#另一个定义" class="headerlink" title="另一个定义"></a>另一个定义</h3><p>类比是闭包确保一个函数永远不会失去连接，到函数诞生地存在的变量，它记得变量，即使在出生地消失之后</p><p>就像一个不会失去联系的人到他们的家乡，在这个类比当中，人就是函数，而家乡是函数的父范围,然后该功能不会失去连接到存储在此父级范围中的变量</p><h2 id="如果没有函数返回值"><a href="#如果没有函数返回值" class="headerlink" title="如果没有函数返回值"></a>如果没有函数返回值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a;<br><br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> c = <span class="hljs-number">777</span>;<br>  a = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    consnole.<span class="hljs-title function_">log</span>(c * <span class="hljs-number">2</span>);<br>  &#125;;<br>&#125;;<br><br><span class="hljs-title function_">a</span>(); <span class="hljs-comment">//会提示未定义</span><br><br><span class="hljs-title function_">b</span>();当调用完a之后，会关闭b的变量环境<br><span class="hljs-title function_">a</span>(); <span class="hljs-comment">//输出结果是c*2的值</span><br></code></pre></td></tr></table></figure><h2 id="内部作用域的属性在-scopes-里面"><a href="#内部作用域的属性在-scopes-里面" class="headerlink" title="内部作用域的属性在 scopes 里面"></a>内部作用域的属性在 scopes 里面</h2><h3 id="closure：获取父函数的的变量"><a href="#closure：获取父函数的的变量" class="headerlink" title="closure：获取父函数的的变量"></a>closure：获取父函数的的变量</h3><p>双括号代表是一个内部属性,无法从代码中访问</p><h2 id="立即调用函数表达式，简称-IIFE"><a href="#立即调用函数表达式，简称-IIFE" class="headerlink" title="立即调用函数表达式，简称 IIFE"></a>立即调用函数表达式，简称 IIFE</h2><p>用括号去欺骗 JavaScript 来进行使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  执行语句;<br>&#125;)();<br><br>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;123&quot;</span>))();<br></code></pre></td></tr></table></figure><p>立即创建，立即调用</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串</title>
    <link href="/2022/05/12/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/05/12/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串的一些方法"><a href="#字符串的一些方法" class="headerlink" title="字符串的一些方法"></a>字符串的一些方法</h1><h2 id="slice-截取"><a href="#slice-截取" class="headerlink" title="slice 截取"></a>slice 截取</h2><p>slice(起始位置，结束位置)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;HelloWorld&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>)); <span class="hljs-comment">// lowo</span><br></code></pre></td></tr></table></figure><p>语法</p><p>str.slice(beginIndex[, endIndex])</p><p>截取这个区间下标的元素：[beginIndex,endIndex)</p><ul><li><p>beginIndex</p><ul><li>从该索引（以 0 为基数）处开始提取原字符串中的字符。如果值为负数，会被当做 strLength + beginIndex 看待，这里的 strLength 是字符串的长度（例如， 如果 beginIndex 是 -3 则看作是：strLength - 3）</li></ul></li><li><p>endIndex</p><ul><li>可选。在该索引（以 0 为基数）处结束提取字符串。如果省略该参数，slice() 会一直提取到字符串末尾。如果该参数为负数，则被看作是 strLength + endIndex，这里的 strLength 就是字符串的长度(例如，如果 endIndex 是 -3，则是, strLength - 3)。</li></ul></li></ul><h2 id="toUpperCase-字符串转大写-x2F-toLowerCase-字符串转小写"><a href="#toUpperCase-字符串转大写-x2F-toLowerCase-字符串转小写" class="headerlink" title="toUpperCase()字符串转大写&#x2F;toLowerCase()字符串转小写"></a>toUpperCase()字符串转大写&#x2F;toLowerCase()字符串转小写</h2><p>语法</p><p>str.toUpperCase()字符串转大写</p><p>str.toLowerCase()字符串转小写</p><h2 id="split-分隔符"><a href="#split-分隔符" class="headerlink" title="split(分隔符)"></a>split(分隔符)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;123 456 789&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>));<br><span class="hljs-comment">//[123,456,789]</span><br></code></pre></td></tr></table></figure><p>通过参数来对字符串进行分割, 并以数组的形式打印出来;</p><h2 id="padStart-x2F-padEnd-填充方法"><a href="#padStart-x2F-padEnd-填充方法" class="headerlink" title="padStart&#x2F;padEnd 填充方法"></a>padStart&#x2F;padEnd 填充方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;123 456 789&quot;</span>;<br>str.<span class="hljs-title function_">padStart</span>(<span class="hljs-number">5</span>, <span class="hljs-number">111</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-property">length</span>);<br><span class="hljs-comment">// 11111123 456 789</span><br><span class="hljs-comment">// 第一个参数是字符串填充到多少长度，如果字符串本身长度超过第一个参数，则还是原来的字符串</span><br><span class="hljs-comment">// 第二个参数是填充的内容</span><br></code></pre></td></tr></table></figure><p>会在字符串开头或者末尾添加参数</p><h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h2><p>重复添加</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;你好&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">repeat</span>(<span class="hljs-number">5</span>));<br></code></pre></td></tr></table></figure><p><img src="https://s1.328888.xyz/2022/05/15/qkVSq.png" alt="qkVSq.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sets和map</title>
    <link href="/2022/05/10/sets%E5%92%8Cmaps/"/>
    <url>/2022/05/10/sets%E5%92%8Cmaps/</url>
    
    <content type="html"><![CDATA[<h1 id="内置数据对象"><a href="#内置数据对象" class="headerlink" title="内置数据对象"></a>内置数据对象</h1><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(数据);<br><span class="hljs-comment">//如果数据是一个数组，则将里面重复的部分去掉，如果是一串字符串，则分解这一段字符串</span><br></code></pre></td></tr></table></figure><h2 id="size-属性"><a href="#size-属性" class="headerlink" title="size 属性"></a>size 属性</h2><p>set.size</p><p>新创建的 Set 数据类型不能使用 length 来获取长度，则使用 size 来获取长度</p><p>获取调用它的对象或者数组</p><h2 id="has-方法"><a href="#has-方法" class="headerlink" title="has 方法"></a>has 方法</h2><p>set.has()</p><p>查询某个元素是否在 set 中</p><h2 id="add-方法"><a href="#add-方法" class="headerlink" title="add 方法"></a>add 方法</h2><p>set.add()</p><p>在 set 中添加一个元素</p><h2 id="delete-方法"><a href="#delete-方法" class="headerlink" title="delete 方法"></a>delete 方法</h2><p>set.delete(‘删除的元素值’)</p><p>删除 set 中的一个元素</p><h2 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear 方法"></a>clear 方法</h2><p>set.clear()</p><p>删除 set 中所有的元素</p><h2 id="set-不能使用下标来检索数据"><a href="#set-不能使用下标来检索数据" class="headerlink" title="set 不能使用下标来检索数据"></a>set 不能使用下标来检索数据</h2><p>如果你的需求是实际按顺序存储值，并且检索它，那么最好的用法是用数组、</p><p>没有必要从 set 中获取值</p><p>当然，set 也是可以用 for of 来遍历里面的元素的</p><p>也可以用拓展运算符对 set 结构进行解构<br><img src="https://s1.328888.xyz/2022/05/10/H8z23.png" alt="H8z23.png"></p><h1 id="map-对象"><a href="#map-对象" class="headerlink" title="map 对象"></a>map 对象</h1><p>Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值（对象或者原始数据类型（string,number,…））都可以作为一个键或一个值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//实例化一个map对象</span><br><span class="hljs-keyword">let</span> mapp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br><span class="hljs-comment">//map通过set方法来添加键值对</span><br>mapp.<span class="hljs-title function_">set</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br><span class="hljs-comment">//map通过get方法获取键对应的值</span><br>mapp.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure><p>同样，map 对象也能使用 set 对象的方法和属性(size,has()…)</p><h2 id="可以使用数组作为-map-的键名"><a href="#可以使用数组作为-map-的键名" class="headerlink" title="可以使用数组作为 map 的键名"></a>可以使用数组作为 map 的键名</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><br>mapp.<span class="hljs-title function_">set</span>(arr, <span class="hljs-string">&quot;HelloWorld&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mapp.<span class="hljs-title function_">get</span>(arr));<br></code></pre></td></tr></table></figure><p>这里数组名仅仅只是当作键的名字而已</p><p><img src="https://s1.328888.xyz/2022/05/11/HsxsO.png" alt="HsxsO.png"></p><h2 id="甚至页面元素也可以作为键名来使用"><a href="#甚至页面元素也可以作为键名来使用" class="headerlink" title="甚至页面元素也可以作为键名来使用"></a>甚至页面元素也可以作为键名来使用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">rest.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;h1&quot;</span>), <span class="hljs-string">&quot;你好！&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://s1.328888.xyz/2022/05/11/H7ykA.png" alt="H7ykA.png"></p><h2 id="批量添加-map-元素"><a href="#批量添加-map-元素" class="headerlink" title="批量添加 map 元素"></a>批量添加 map 元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> end2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&quot;name1&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>],<br>  [<span class="hljs-string">&quot;name2&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>],<br>  [<span class="hljs-string">&quot;name3&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>],<br>]);<br></code></pre></td></tr></table></figure><p><img src="https://s1.328888.xyz/2022/05/11/H77UZ.png" alt="H77UZ.png"></p><h2 id="object-转-map"><a href="#object-转-map" class="headerlink" title="object 转 map"></a>object 转 map</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;医生&quot;</span> &#125;;<br><span class="hljs-keyword">let</span> mpp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(obj));<br></code></pre></td></tr></table></figure><p><img src="https://s1.328888.xyz/2022/05/11/H7IqC.png" alt="H7IqC.png"></p><h2 id="遍历-map"><a href="#遍历-map" class="headerlink" title="遍历 map"></a>遍历 map</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [index, value] <span class="hljs-keyword">of</span> mpp.<span class="hljs-title function_">entries</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index, value);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s1.328888.xyz/2022/05/11/H7anm.png" alt="H7anm.png"></p><h2 id="可以用拓展运算符（…）把-map-转换成数组"><a href="#可以用拓展运算符（…）把-map-转换成数组" class="headerlink" title="可以用拓展运算符（…）把 map 转换成数组"></a>可以用拓展运算符（…）把 map 转换成数组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...mpp]);<br></code></pre></td></tr></table></figure><p><img src="https://s1.328888.xyz/2022/05/11/HIt3S.png" alt="HIt3S.png"></p><h2 id="也可以使用-keys-values-entries-方法"><a href="#也可以使用-keys-values-entries-方法" class="headerlink" title="也可以使用 keys,values,entries 方法"></a>也可以使用 keys,values,entries 方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...mpp.<span class="hljs-title function_">keys</span>()]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...mpp.<span class="hljs-title function_">values</span>()]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([...mpp.<span class="hljs-title function_">entries</span>()]);<br></code></pre></td></tr></table></figure><p><img src="https://s1.328888.xyz/2022/05/11/HI7CF.png" alt="HI7CF.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>遍历数组和对象</title>
    <link href="/2022/05/09/%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/05/09/%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="For-of"><a href="#For-of" class="headerlink" title="For-of"></a>For-of</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> 变量名||&#123;变量<span class="hljs-number">1</span>，变量<span class="hljs-number">2</span>&#125; <span class="hljs-keyword">of</span> 数组名||数组名.<span class="hljs-title function_">entries</span>())&#123;<br><span class="hljs-number">1</span>：下标<br><span class="hljs-number">2</span>：下标对应的元素<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>把对象先转换成数组的形式，然后进行遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property">keys</span><br>只获取对象中属性的名称，也就是键名<br><span class="hljs-title class_">Object</span>.<span class="hljs-property">values</span><br>把对象的格式转成数组的格式，第一层的属性名被替换成下标<br><span class="hljs-title class_">Object</span>.<span class="hljs-property">entries</span><br>将全部对象全部转换成数组<br></code></pre></td></tr></table></figure><p><img src="https://s1.328888.xyz/2022/05/10/HULz4.png" alt="HULz4.png"><br><img src="https://s1.328888.xyz/2022/05/10/HUJJ3.png" alt="HUJJ3.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拓展运算符</title>
    <link href="/2022/05/08/%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2022/05/08/%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="在右边时：…变量名"><a href="#在右边时：…变量名" class="headerlink" title="在右边时：…变量名"></a>在右边时：…变量名</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, ...arr];<br><span class="hljs-comment">//arr1 = [1,2,3,1,2,3,4]</span><br>...arr把整个arr的数组解构成一个个的元素，这个也可以用于解构对象<br><br></code></pre></td></tr></table></figure><h2 id="在左边时：…变量名"><a href="#在左边时：…变量名" class="headerlink" title="在左边时：…变量名"></a>在左边时：…变量名</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>];<br><span class="hljs-keyword">const</span> [a, b, c, ...arr2] = arr;<br><span class="hljs-comment">//arr2 = [4,5,6,7]</span><br>在左边时将剩余的数组元素合并成一个数组;<br>当作为函数的参数使用时，会将传递的实参全部存入，和<span class="hljs-variable language_">arguments</span>类似<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM</title>
    <link href="/2022/04/28/DOM/"/>
    <url>/2022/04/28/DOM/</url>
    
    <content type="html"><![CDATA[<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>DOM 代表文档对象模型</p><p>DOM 允许我们操作 HTML 元素</p><p>DOm 连接 HTML 与 JS 交互</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象</title>
    <link href="/2022/04/25/%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/04/25/%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> 对象名 = &#123;属性<span class="hljs-number">1</span>，属性<span class="hljs-number">2</span>，属性<span class="hljs-number">3.</span>..&#125;<br></code></pre></td></tr></table></figure><p>数组通过下标访问数据，对象通过属性名访问数据</p><h2 id="访问数据的方法"><a href="#访问数据的方法" class="headerlink" title="访问数据的方法"></a>访问数据的方法</h2><ol><li>对象名.属性名</li><li>对象名[‘属性名’] (可以用一个变量来存储属性名)</li></ol><p>对面里面也可以存函数，这个函数叫做这个对象的方法</p><h2 id="方法里面的-this-指向"><a href="#方法里面的-this-指向" class="headerlink" title="方法里面的 this 指向"></a>方法里面的 this 指向</h2><p>谁调用方法，this 就代表哪个对象</p><p>数组实际上是一种特殊的对象，它们有自己的方法<br>例如：push,unshift</p><p>一个对象的方法如果被赋值给了其他变量，则这个变量获得的值只是一个全局的函数，并不是对象的方法本身</p><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>手动并明确的设置 this 关键字</p><p>call(需要指向的 this,调用方法时的参数)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 初始化两个对象</span><br><span class="hljs-keyword">const</span> name = &#123;<br>  <span class="hljs-attr">namne</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;男&quot;</span>,<br>  <span class="hljs-attr">arr</span>: [],<br>  <span class="hljs-title function_">show</span>(<span class="hljs-params">name, sex</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: name, <span class="hljs-attr">sex</span>: sex &#125;);<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> name2 = &#123;<br>  <span class="hljs-attr">namne2</span>: <span class="hljs-string">&quot;小A&quot;</span>,<br>  <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;男&quot;</span>,<br>  <span class="hljs-attr">arr</span>: [],<br>&#125;;<br><br><span class="hljs-comment">// 把name里面的函数提出来</span><br><span class="hljs-keyword">const</span> show2 = name.<span class="hljs-property">show</span>;<br><br><span class="hljs-comment">//调用show2，并使用call将show方法里面的this指向name2和name</span><br><span class="hljs-comment">// 后面的参数是方法接收的参数</span><br>show2.<span class="hljs-title function_">call</span>(name, <span class="hljs-string">&quot;小南&quot;</span>, <span class="hljs-string">&quot;女&quot;</span>);<br><br>show2.<span class="hljs-title function_">call</span>(name2, <span class="hljs-string">&quot;小A&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);<br><br>name.<span class="hljs-title function_">show</span>(<span class="hljs-string">&quot;小王&quot;</span>, <span class="hljs-string">&quot;男&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name2);<br></code></pre></td></tr></table></figure><p><img src="https://s1.328888.xyz/2022/05/22/dR9Jv.png" alt="dR9Jv.png"></p><p>可以看见这里 name,和 name2 对象里面 arr 数组通过 show2 的方法添加了元素</p><p>通过 call，能够使用另一个对象里面的方法</p><h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><p>bind 方法创建一个新的函数</p><p>在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> show = name.<span class="hljs-property">show</span>.<span class="hljs-title function_">bind</span>(name, <span class="hljs-string">&quot;小南&quot;</span>);<br><span class="hljs-comment">//此时show等同于name对象里面的show,this会指向name对象,而后面的参数会变成新函数的参数</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/2022/04/25/%E6%95%B0%E7%BB%84/"/>
    <url>/2022/04/25/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="创建数组的方法"><a href="#创建数组的方法" class="headerlink" title="创建数组的方法"></a>创建数组的方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> 数组名 = [元素<span class="hljs-number">1</span>，元素<span class="hljs-number">2</span>，元素<span class="hljs-number">3.</span>..]<br><br><span class="hljs-keyword">let</span> 数组名 <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(元素<span class="hljs-number">1</span>，元素<span class="hljs-number">2</span>，元素<span class="hljs-number">3.</span>..)<br></code></pre></td></tr></table></figure><p>数组下标通常以 0 开始</p><p>数组名.length(length 能获取数组中元素的个数)</p><p>以 const 声明的数组，后面可以改变它的值</p><p>数组内的元素可以是任意表达式，例如：函数，字符串，数字等等</p><hr><h1 id="内置数组函数"><a href="#内置数组函数" class="headerlink" title="内置数组函数"></a>内置数组函数</h1><h2 id="在数组末尾添加元素"><a href="#在数组末尾添加元素" class="headerlink" title="在数组末尾添加元素"></a>在数组末尾添加元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">数组名.<span class="hljs-title function_">push</span>(要添加的元素);<br></code></pre></td></tr></table></figure><h2 id="在数组开头添加元素"><a href="#在数组开头添加元素" class="headerlink" title="在数组开头添加元素"></a>在数组开头添加元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">数组名.<span class="hljs-title function_">unshift</span>(要添加的元素);<br></code></pre></td></tr></table></figure><p><strong>上面两个内置函数有返回值，返回值是新数组的长度</strong></p><h2 id="删除数组最后一个元素"><a href="#删除数组最后一个元素" class="headerlink" title="删除数组最后一个元素"></a>删除数组最后一个元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">数组名.<span class="hljs-title function_">pop</span>();<br><span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><h2 id="删除数组的第一个元素"><a href="#删除数组的第一个元素" class="headerlink" title="删除数组的第一个元素"></a>删除数组的第一个元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">数组名.<span class="hljs-title function_">unshift</span>(要删除的元素);<br></code></pre></td></tr></table></figure><p><strong>上面两个内置函数有返回值，返回值是被删除的元素</strong></p><h2 id="删除数组的第一个元素-1"><a href="#删除数组的第一个元素-1" class="headerlink" title="删除数组的第一个元素"></a>删除数组的第一个元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">数组名.<span class="hljs-title function_">unshift</span>(要删除的元素);<br></code></pre></td></tr></table></figure><h2 id="查询数组中某个元素的下标"><a href="#查询数组中某个元素的下标" class="headerlink" title="查询数组中某个元素的下标"></a>查询数组中某个元素的下标</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">数组名.<span class="hljs-title function_">indexOf</span>(要查找的元素);<br></code></pre></td></tr></table></figure><p><strong>如果有，则返回该元素对应的下标</strong></p><p><strong>如果没找到该元素，则返回-1</strong></p><h2 id="查询数组中是否包含某个元素"><a href="#查询数组中是否包含某个元素" class="headerlink" title="查询数组中是否包含某个元素"></a>查询数组中是否包含某个元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">数组名.<span class="hljs-title function_">includes</span>(要查找的元素);<br></code></pre></td></tr></table></figure><p>有则返回 true,<br>无则返回 false</p><h2 id="数组进阶"><a href="#数组进阶" class="headerlink" title="数组进阶"></a>数组进阶</h2>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS函数</title>
    <link href="/2022/04/24/JS%E5%87%BD%E6%95%B0/"/>
    <url>/2022/04/24/JS%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="声明函数"><a href="#声明函数" class="headerlink" title="声明函数"></a>声明函数</h2><p>可以全局使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">calcAge</span>(<span class="hljs-params">形参</span>) &#123;<br>  <span class="hljs-keyword">return</span> 返回值;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p>不能全局使用，得先定义才能使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> calcAge = <span class="hljs-keyword">function</span> (<span class="hljs-params">形参</span>) &#123;<br>  <span class="hljs-keyword">return</span> 返回值;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>函数表达式，适合快速的单行功能，函数内只有一条表达式的情况下不需要使用 return 返回，箭头函数内的返回是隐式的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">calcAge</span> = (<span class="hljs-params">形参</span>) =&gt; &#123;<br>  <span class="hljs-comment">//多行需要使用return</span><br>  <span class="hljs-keyword">return</span> 返回值;<br>&#125;;<br></code></pre></td></tr></table></figure><p>函数通常以遇到的第一个 return 而结束</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jsonp</title>
    <link href="/2022/03/28/jsonp/"/>
    <url>/2022/03/28/jsonp/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AJAX_1</title>
    <link href="/2022/03/25/AJAX-1/"/>
    <url>/2022/03/25/AJAX-1/</url>
    
    <content type="html"><![CDATA[<h1 id="ajax-内部是咋写的"><a href="#ajax-内部是咋写的" class="headerlink" title="ajax 内部是咋写的"></a>ajax 内部是咋写的</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> oBtn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn1&quot;</span>);<br>oBtn.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><br>  <span class="hljs-comment">//连接请求</span><br>  xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;1.php?a=12&amp;b=5&quot;</span>, <span class="hljs-literal">true</span>);<br><br>  <span class="hljs-comment">//发送请求</span><br>  xhr.<span class="hljs-title function_">send</span>();<br><br>  <span class="hljs-comment">//接收请求</span><br>  xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//readyState的值表示目前通信处于什么状态</span><br>    <span class="hljs-comment">//0初始化-刚刚创建</span><br>    <span class="hljs-comment">//1以连接</span><br>    <span class="hljs-comment">//2已发送</span><br>    <span class="hljs-comment">//3已接收-头</span><br>    <span class="hljs-comment">//4已接收-主体内容</span><br>    <span class="hljs-title function_">alert</span>(xhr.<span class="hljs-property">readyState</span>);<br>    <span class="hljs-comment">//不管请求成果或者失败，都会执行完4的内容</span><br>    <span class="hljs-comment">//这时候需要用到http状态码了</span><br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="http-状态码-status"><a href="#http-状态码-status" class="headerlink" title="http 状态码(status)"></a>http 状态码(status)</h2><p>游览器和服务器之间通过数字来表明状态,这个数字就是 http 状态码</p><p>1xx 消息</p><p>2xx 成功</p><p>3xx 重定向：原来的地址更改到了新的地址</p><p>​ 301：永久重定向-游览器不会再次请求老的地址</p><p>​ 302：临时重定向-游览器下次还会请求老地址</p><p>​ 304：缓存</p><p>4xx 请求错误（客户端）</p><p>5xx 服务端错误</p><p>6xx 拓展</p><p>所以，想要知道是否成功，就要看状态码是否是 2xx 或者 304</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> == <span class="hljs-number">4</span>) &#123;<br>    <span class="hljs-keyword">if</span> ((xhr.<span class="hljs-property">status</span> &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.<span class="hljs-property">status</span> &lt;= <span class="hljs-number">300</span>) || xhr.<span class="hljs-property">status</span> == <span class="hljs-number">304</span>) &#123;<br>      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;成功&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;失败&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/.io//image/ajax/1.png" alt="image"></p><p>改成 1.php 就能成功了</p><p><img src="/.io//image/ajax/2.png" alt="image"></p><p>如果使用 post 请求，则需要添加一条额外的语句</p><p><img src="/.io//image/ajax/3.png" alt="image"></p><p>放在 open 和 send 之间</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>async/await操作</title>
    <link href="/2022/03/24/async-await%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/03/24/async-await%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="async-x2F-await-操作"><a href="#async-x2F-await-操作" class="headerlink" title="async&#x2F;await 操作"></a>async&#x2F;await 操作</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>    ...<br>    ...<br>    <span class="hljs-keyword">let</span> 结果=<span class="hljs-keyword">await</span> 异步操作-promise，generator，另一个<span class="hljs-keyword">async</span>函数<br>    <span class="hljs-keyword">let</span> 结果=<span class="hljs-keyword">await</span> 异步操作-promise，generator，另一个<span class="hljs-keyword">async</span>函数<br>    <span class="hljs-keyword">let</span> 结果=<span class="hljs-keyword">await</span> 异步操作-promise，generator，另一个<span class="hljs-keyword">async</span>函数<br>    <span class="hljs-comment">//和generator用法类似,可以处理多个异步请求，可以不用前面的premise.all</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js_es6面向对象</title>
    <link href="/2022/03/23/js-es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/03/23/js-es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="es6-面向对象"><a href="#es6-面向对象" class="headerlink" title="es6 面向对象"></a>es6 面向对象</h1><p>es6 的面向对象相对于传统 js 面向对象方便了很多</p><p>不需要用 function 来创建一个类</p><p>和 java 类似</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> 对象名 &#123;<br>  <span class="hljs-title class_">Constructor</span>() &#123;<br>    这里写属性;<br>  &#125;<br>  这里写函数;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/.io//image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.png" alt="image"></p><h2 id="es6-的继承"><a href="#es6-的继承" class="headerlink" title="es6 的继承"></a>es6 的继承</h2><p>Es6 通过 super 来继承父类的属性</p><p>父类的方法通过 extends 来继承</p><p><img src="/.io//image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3.png" alt="image"></p><p><img src="/.io//image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2.png" alt="image"></p><h2 id="es6-面向对象的-this"><a href="#es6-面向对象的-this" class="headerlink" title="es6 面向对象的 this"></a>es6 面向对象的 this</h2><p>js 的 this 容易被改变，这里本来应该显示 blue 的，但 this 现在指向了 document</p><p><img src="/.io//image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4.png" alt="image"></p><p>修改的方法是在对象的方法后面，跟上一个 bind（blue）</p><p>这里修改成 blue.showName.bind(blue)</p><p>bind 是强制改变 this 的指向</p><p>bind 的可以修改 this 指向的对象</p><p>和 js 的 call 这个方法类似</p><h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h2><p>箭头函数：根据我所在的环境，环境是谁 this 就是谁</p><p><img src="/.io//image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5.png" alt="image"></p><p>这里别的实例对象用这个方法的时候，就不需要要用 bind 来改变指向了，这里 this 处在哪个环境，this 就是谁</p><p><img src="/.io//image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/6.png" alt="image"></p><p>普通函数：谁在调用 this，this 就是谁</p><p>上一节点击事件的错误就是因为是普通函数的缘故，this 指向了 document。</p><h2 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h2><p>拥有同步的简便，和异步的优点</p><p>有两个参数 resolve 和 reject</p><p>resolve：成功之后调用的函数</p><p>reject：失败之后调用的函数</p><p><img src="/.io//image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/7.png" alt="image"></p><p>promise 这个对象里面能执行一些方法和语句，执行完成后，resolve 和 reject 都会将括号里的值返回出去</p><p>promise 有局限性</p><ol><li>promise 有用-解除异步操作</li><li>有局限-带逻辑的异步操作很麻烦</li></ol><h3 id="promise"><a href="#promise" class="headerlink" title="promise-"></a>promise-</h3><p>promise-race(||的作用)</p><p>promise-all(&amp;&amp;的作用)</p><p>能获取多个地址的数据</p><p><img src="/.io//image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/8.png" alt="image"></p><p>Promise.all([pro 对象 1，pro 对象 2……]).then()</p><p>all 能获取 promise 的集合，可以用数组的形式将这三个对象存起来</p><p><img src="/.io//image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/9.png" alt="image"></p><p>因为 jQuery 的 Ajax 返回的对象里面，带有 Promise，所以这里 all 里面的对象可以直接用 jQuery 的 Ajax 表达式来使用</p><p><img src="/.io//image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/10.png" alt="image"></p><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>回调：有结果之后来找你</p><ol><li>不是定义的人调用</li><li>什么时候调用不知道</li></ol><p>轮询：一直询问</p><h2 id="generator-函数"><a href="#generator-函数" class="headerlink" title="generator 函数"></a>generator 函数</h2><p>Function *show(){}</p><p>函数名前面加一个*号</p><p>gen 函数与普通函数的区别是能暂停</p><p>并且用 yield 来分块</p><p><img src="/.io//image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/11.png" alt="image"></p><p>这儿已经被分成两块了</p><p>gen 函数直接使用不会生效，而是会产生一个返回值,这里将 show 这个对象给了 fan</p><p><img src="/.io//image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/12.png" alt="image"></p><p>要执行 show 里面的语句，需要用 next 这个方法来驱动</p><p>next 会在 yield 之前停下，如果要执行 yield 后面的语句，需要在调用一下 next 的方法</p><p>这样的好处是，有些异步操作需要时间，然后可以使用 yield 来分块，当异步操作执行完毕后，在执行后面的语句</p><p><img src="/.io//image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/13.png" alt="image"></p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js面向对象</title>
    <link href="/2022/03/21/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/03/21/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="js-面向对象"><a href="#js-面向对象" class="headerlink" title="js 面向对象"></a>js 面向对象</h1><blockquote><p><a href="https://www.jianshu.com/p/f9792fdd9915">参考了该文章：JavaScript 面向对象 - 简书 (jianshu.com)</a></p></blockquote><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCar</span>(<span class="hljs-params">color,wheel</span>)</span>&#123;<span class="hljs-comment">//createCar工厂</span><br>    <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>;<span class="hljs-comment">//或obj = &#123;&#125; 原材料阶段</span><br>    obj.color = <span class="hljs-built_in">color</span>;<span class="hljs-comment">//加工</span><br>    obj.wheel = wheel;<span class="hljs-comment">//加工</span><br>    <span class="hljs-keyword">return</span> obj;<span class="hljs-comment">//输出产品</span><br>&#125;<br><span class="hljs-comment">//实例化</span><br><span class="hljs-keyword">var</span> cat1 = createCar(<span class="hljs-string">&quot;红色&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>);<br><span class="hljs-keyword">var</span> cat2 = createCar(<span class="hljs-string">&quot;蓝色&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>);<br><br>alert(cat1.color);<span class="hljs-comment">//红色</span><br></code></pre></td></tr></table></figure><p>工厂模式对传入的值进行加工，然后输出</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><strong>构造函数就是类</strong></p><p>构造函数用于写属性</p><p><img src="/.io//image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.png" alt="image"></p><p>当我们 new 这个类的时候，这里的 name 和 sex 会作为属性一并被赋给 obj3</p><p><img src="/.io//image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2.png" alt="image"></p><p>我这儿构造函数的命名不规范，应该首字母大写</p><h2 id="原型（prototype）"><a href="#原型（prototype）" class="headerlink" title="原型（prototype）"></a>原型（prototype）</h2><p>*每个函数都有一个属性——****prototype**<strong>。这个*</strong>*prototype**<strong>的属性值是一个对象（属性的集合），默认只有一个叫做*</strong>*constructor****的属性，指向这个函数本身**</p><p><img src="/.io//image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3.png" alt="image"></p><p>这里是给 createPre 类，添加一个 showName 的方法，然后后面创建实例化对象（obj3）的时候，这个 obj3 会有这个方法</p><p><img src="/.io//image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4.png" alt="image"></p><h2 id="构造函数和原型的用法"><a href="#构造函数和原型的用法" class="headerlink" title="构造函数和原型的用法"></a>构造函数和原型的用法</h2><p>构造函数里面加属性，原型里面加方法</p><p><img src="/.io//image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5.png" alt="image"></p><p><strong>这里再放一张容易理解对象的图</strong></p><p><img src="/.io//image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/6.png" alt="image"></p><p><img src="/.io//image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/7.png" alt="image"></p><p>这里的不同颜色的车和不同种类的狗，就是 new 出来的实例对象</p><h2 id="命令空间"><a href="#命令空间" class="headerlink" title="命令空间"></a>命令空间</h2><p><img src="/.io//image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/8.png" alt="image"></p><p>不同对象，相同方法</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>js 通过 call 方法来继承父元素的属性</p><p>call 方法：可以改变函数执行的时候，里面的 this</p><p><img src="/.io//image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/9.png" alt="image"></p><p>call 可以传参数，这里的 this 就是 show2 这个对象</p><p>call 将 show2 这个对象传入 show</p><p>然后将 show 里面 this 指向指为 show2</p><h3 id="继承的问题"><a href="#继承的问题" class="headerlink" title="继承的问题"></a>继承的问题</h3><p>这里举个栗子</p><p><img src="/.io//image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/10.png" alt="image"></p><p>这里 arr2 并不是复制了一份 arr1，而是将 arr2 也指向了 arr1 的空间了</p><p>他们都指向了同一块空间</p><p><img src="/.io//image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/14.png" alt="image"></p><p>可以看见这个 arr1 里面的数据也被更改了</p><p>解决这个问题的方法是，用循环将 arr1 里面的数据传入 arr2</p><p><img src="/.io//image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/11.png" alt="image"></p><p>对象里面，方法的继承也存在同样的问题</p><p><img src="/.io//image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/13.png" alt="image"></p><p>这样做的话，会和上面数组的问题一样，修改 show2 的方法，show 的方法也会被修改</p><p><img src="/.io//image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/12.png" alt="image"></p><p>这样就不会出问题了</p><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p><img src="/.io//image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/15.png" alt="image"></p><p>重写就是将新的原型里面的方法，给重新写一遍</p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
