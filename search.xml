<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DOM</title>
    <url>/2022/04/28/DOM/</url>
    <content><![CDATA[<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>DOM 代表文档对象模型</p>
<p>DOM 允许我们操作 HTML 元素</p>
<p>DOm 连接 HTML 与 JS 交互</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>AJAX_1</title>
    <url>/2022/03/25/AJAX-1/</url>
    <content><![CDATA[<h1 id="ajax-内部是咋写的"><a href="#ajax-内部是咋写的" class="headerlink" title="ajax 内部是咋写的"></a>ajax 内部是咋写的</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn1&quot;</span>);</span><br><span class="line">oBtn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//连接请求</span></span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;1.php?a=12&amp;b=5&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//发送请求</span></span><br><span class="line">  xhr.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//接收请求</span></span><br><span class="line">  xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//readyState的值表示目前通信处于什么状态</span></span><br><span class="line">    <span class="comment">//0	初始化-刚刚创建</span></span><br><span class="line">    <span class="comment">//1	以连接</span></span><br><span class="line">    <span class="comment">//2	已发送</span></span><br><span class="line">    <span class="comment">//3	已接收-头</span></span><br><span class="line">    <span class="comment">//4	已接收-主体内容</span></span><br><span class="line">    <span class="title function_">alert</span>(xhr.<span class="property">readyState</span>);</span><br><span class="line">    <span class="comment">//不管请求成果或者失败，都会执行完4的内容</span></span><br><span class="line">    <span class="comment">//这时候需要用到http状态码了</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="http-状态码-status"><a href="#http-状态码-status" class="headerlink" title="http 状态码(status)"></a>http 状态码(status)</h2><p>游览器和服务器之间通过数字来表明状态,这个数字就是 http 状态码</p>
<p>1xx 消息</p>
<p>2xx 成功</p>
<p>3xx 重定向：原来的地址更改到了新的地址</p>
<p>​ 301：永久重定向-游览器不会再次请求老的地址</p>
<p>​ 302：临时重定向-游览器下次还会请求老地址</p>
<p>​ 304：缓存</p>
<p>4xx 请求错误（客户端）</p>
<p>5xx 服务端错误</p>
<p>6xx 拓展</p>
<p>所以，想要知道是否成功，就要看状态码是否是 2xx 或者 304</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt;= <span class="number">300</span>) || xhr.<span class="property">status</span> == <span class="number">304</span>) &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="/../image/ajax/1.png"></p>
<p>改成 1.php 就能成功了</p>
<p><img lazyload alt="image" data-src="/../image/ajax/2.png"></p>
<p>如果使用 post 请求，则需要添加一条额外的语句</p>
<p><img lazyload alt="image" data-src="/../image/ajax/3.png"></p>
<p>放在 open 和 send 之间</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>async/await操作</title>
    <url>/2022/03/24/async-await%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="async-x2F-await-操作"><a href="#async-x2F-await-操作" class="headerlink" title="async&#x2F;await 操作"></a>async&#x2F;await 操作</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">let</span> 结果=<span class="keyword">await</span> 异步操作-promise，generator，另一个<span class="keyword">async</span>函数</span><br><span class="line">    <span class="keyword">let</span> 结果=<span class="keyword">await</span> 异步操作-promise，generator，另一个<span class="keyword">async</span>函数</span><br><span class="line">    <span class="keyword">let</span> 结果=<span class="keyword">await</span> 异步操作-promise，generator，另一个<span class="keyword">async</span>函数</span><br><span class="line">    <span class="comment">//和generator用法类似,可以处理多个异步请求，可以不用前面的premise.all</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JS函数</title>
    <url>/2022/04/24/JS%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="声明函数"><a href="#声明函数" class="headerlink" title="声明函数"></a>声明函数</h2><p>可以全局使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calcAge</span>(<span class="params">形参</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p>不能全局使用，得先定义才能使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> calcAge = <span class="keyword">function</span> (<span class="params">形参</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>函数表达式，适合快速的单行功能，函数内只有一条表达式的情况下不需要使用 return 返回，箭头函数内的返回是隐式的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">calcAge</span> = (<span class="params">形参</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">//多行需要使用return</span></span><br><span class="line">  <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>函数通常以遇到的第一个 return 而结束</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js_es6面向对象</title>
    <url>/2022/03/23/js-es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="es6-面向对象"><a href="#es6-面向对象" class="headerlink" title="es6 面向对象"></a>es6 面向对象</h1><p>es6 的面向对象相对于传统 js 面向对象方便了很多</p>
<p>不需要用 function 来创建一个类</p>
<p>和 java 类似</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 对象名 &#123;</span><br><span class="line">  <span class="title class_">Constructor</span>() &#123;</span><br><span class="line">    这里写属性;</span><br><span class="line">  &#125;</span><br><span class="line">  这里写函数;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.png"></p>
<h2 id="es6-的继承"><a href="#es6-的继承" class="headerlink" title="es6 的继承"></a>es6 的继承</h2><p>Es6 通过 super 来继承父类的属性</p>
<p>父类的方法通过 extends 来继承</p>
<p><img lazyload alt="image" data-src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3.png"></p>
<p><img lazyload alt="image" data-src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2.png"></p>
<h2 id="es6-面向对象的-this"><a href="#es6-面向对象的-this" class="headerlink" title="es6 面向对象的 this"></a>es6 面向对象的 this</h2><p>js 的 this 容易被改变，这里本来应该显示 blue 的，但 this 现在指向了 document</p>
<p><img lazyload alt="image" data-src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4.png"></p>
<p>修改的方法是在对象的方法后面，跟上一个 bind（blue）</p>
<p>这里修改成 blue.showName.bind(blue)</p>
<p>bind 是强制改变 this 的指向</p>
<p>bind 的可以修改 this 指向的对象</p>
<p>和 js 的 call 这个方法类似</p>
<h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h2><p>箭头函数：根据我所在的环境，环境是谁 this 就是谁</p>
<p><img lazyload alt="image" data-src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5.png"></p>
<p>这里别的实例对象用这个方法的时候，就不需要要用 bind 来改变指向了，这里 this 处在哪个环境，this 就是谁</p>
<p><img lazyload alt="image" data-src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/6.png"></p>
<p>普通函数：谁在调用 this，this 就是谁</p>
<p>上一节点击事件的错误就是因为是普通函数的缘故，this 指向了 document。</p>
<h2 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h2><p>拥有同步的简便，和异步的优点</p>
<p>有两个参数 resolve 和 reject</p>
<p>resolve：成功之后调用的函数</p>
<p>reject：失败之后调用的函数</p>
<p><img lazyload alt="image" data-src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/7.png"></p>
<p>promise 这个对象里面能执行一些方法和语句，执行完成后，resolve 和 reject 都会将括号里的值返回出去</p>
<p>promise 有局限性</p>
<ol>
<li>promise 有用-解除异步操作</li>
<li>有局限-带逻辑的异步操作很麻烦</li>
</ol>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise-"></a>promise-</h3><p>promise-race(||的作用)</p>
<p>promise-all(&amp;&amp;的作用)</p>
<p>能获取多个地址的数据</p>
<p><img lazyload alt="image" data-src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/8.png"></p>
<p>Promise.all([pro 对象 1，pro 对象 2……]).then()</p>
<p>all 能获取 promise 的集合，可以用数组的形式将这三个对象存起来</p>
<p><img lazyload alt="image" data-src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/9.png"></p>
<p>因为 jQuery 的 Ajax 返回的对象里面，带有 Promise，所以这里 all 里面的对象可以直接用 jQuery 的 Ajax 表达式来使用</p>
<p><img lazyload alt="image" data-src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/10.png"></p>
<h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><p>回调：有结果之后来找你</p>
<ol>
<li>不是定义的人调用</li>
<li>什么时候调用不知道</li>
</ol>
<p>轮询：一直询问</p>
<h2 id="generator-函数"><a href="#generator-函数" class="headerlink" title="generator 函数"></a>generator 函数</h2><p>Function *show(){}</p>
<p>函数名前面加一个*号</p>
<p>gen 函数与普通函数的区别是能暂停</p>
<p>并且用 yield 来分块</p>
<p><img lazyload alt="image" data-src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/11.png"></p>
<p>这儿已经被分成两块了</p>
<p>gen 函数直接使用不会生效，而是会产生一个返回值,这里将 show 这个对象给了 fan</p>
<p><img lazyload alt="image" data-src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/12.png"></p>
<p>要执行 show 里面的语句，需要用 next 这个方法来驱动</p>
<p>next 会在 yield 之前停下，如果要执行 yield 后面的语句，需要在调用一下 next 的方法</p>
<p>这样的好处是，有些异步操作需要时间，然后可以使用 yield 来分块，当异步操作执行完毕后，在执行后面的语句</p>
<p><img lazyload alt="image" data-src="/../image/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/13.png"></p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>jsonp</title>
    <url>/2022/03/28/jsonp/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js面向对象</title>
    <url>/2022/03/21/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="js-面向对象"><a href="#js-面向对象" class="headerlink" title="js 面向对象"></a>js 面向对象</h1><blockquote>
<p><a class="link" href="https://www.jianshu.com/p/f9792fdd9915">参考了该文章：JavaScript 面向对象 - 简书 (jianshu.com)<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createCar(color,wheel)&#123;//createCar工厂</span><br><span class="line">    var obj = new Object;//或obj = &#123;&#125; 原材料阶段</span><br><span class="line">    obj.color = color;//加工</span><br><span class="line">    obj.wheel = wheel;//加工</span><br><span class="line">    return obj;//输出产品</span><br><span class="line">&#125;</span><br><span class="line">//实例化</span><br><span class="line">var cat1 = createCar(&quot;红色&quot;,&quot;4&quot;);</span><br><span class="line">var cat2 = createCar(&quot;蓝色&quot;,&quot;4&quot;);</span><br><span class="line"></span><br><span class="line">alert(cat1.color);//红色</span><br></pre></td></tr></table></figure>

<p>工厂模式对传入的值进行加工，然后输出</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><strong>构造函数就是类</strong></p>
<p>构造函数用于写属性</p>
<p><img lazyload alt="image" data-src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.png"></p>
<p>当我们 new 这个类的时候，这里的 name 和 sex 会作为属性一并被赋给 obj3</p>
<p><img lazyload alt="image" data-src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2.png"></p>
<p>我这儿构造函数的命名不规范，应该首字母大写</p>
<h2 id="原型（prototype）"><a href="#原型（prototype）" class="headerlink" title="原型（prototype）"></a>原型（prototype）</h2><p>*每个函数都有一个属性——****prototype**<strong>。这个*</strong>*prototype**<strong>的属性值是一个对象（属性的集合），默认只有一个叫做*</strong>*constructor****的属性，指向这个函数本身**</p>
<p><img lazyload alt="image" data-src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/3.png"></p>
<p>这里是给 createPre 类，添加一个 showName 的方法，然后后面创建实例化对象（obj3）的时候，这个 obj3 会有这个方法</p>
<p><img lazyload alt="image" data-src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/4.png"></p>
<h2 id="构造函数和原型的用法"><a href="#构造函数和原型的用法" class="headerlink" title="构造函数和原型的用法"></a>构造函数和原型的用法</h2><p>构造函数里面加属性，原型里面加方法</p>
<p><img lazyload alt="image" data-src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/5.png"></p>
<p><strong>这里再放一张容易理解对象的图</strong></p>
<p><img lazyload alt="image" data-src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/6.png"></p>
<p><img lazyload alt="image" data-src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/7.png"></p>
<p>这里的不同颜色的车和不同种类的狗，就是 new 出来的实例对象</p>
<h2 id="命令空间"><a href="#命令空间" class="headerlink" title="命令空间"></a>命令空间</h2><p><img lazyload alt="image" data-src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/8.png"></p>
<p>不同对象，相同方法</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>js 通过 call 方法来继承父元素的属性</p>
<p>call 方法：可以改变函数执行的时候，里面的 this</p>
<p><img lazyload alt="image" data-src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/9.png"></p>
<p>call 可以传参数，这里的 this 就是 show2 这个对象</p>
<p>call 将 show2 这个对象传入 show</p>
<p>然后将 show 里面 this 指向指为 show2</p>
<h3 id="继承的问题"><a href="#继承的问题" class="headerlink" title="继承的问题"></a>继承的问题</h3><p>这里举个栗子</p>
<p><img lazyload alt="image" data-src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/10.png"></p>
<p>这里 arr2 并不是复制了一份 arr1，而是将 arr2 也指向了 arr1 的空间了</p>
<p>他们都指向了同一块空间</p>
<p><img lazyload alt="image" data-src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/14.png"></p>
<p>可以看见这个 arr1 里面的数据也被更改了</p>
<p>解决这个问题的方法是，用循环将 arr1 里面的数据传入 arr2</p>
<p><img lazyload alt="image" data-src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/11.png"></p>
<p>对象里面，方法的继承也存在同样的问题</p>
<p><img lazyload alt="image" data-src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/13.png"></p>
<p>这样做的话，会和上面数组的问题一样，修改 show2 的方法，show 的方法也会被修改</p>
<p><img lazyload alt="image" data-src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/12.png"></p>
<p>这样就不会出问题了</p>
<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p><img lazyload alt="image" data-src="/../image/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/15.png"></p>
<p>重写就是将新的原型里面的方法，给重新写一遍</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>node</title>
    <url>/2022/11/30/node/</url>
    <content><![CDATA[<p><a href="/download/node.zip">下载文件</a></p>
]]></content>
  </entry>
  <entry>
    <title>sets和map</title>
    <url>/2022/05/10/sets%E5%92%8Cmaps/</url>
    <content><![CDATA[<h1 id="内置数据对象"><a href="#内置数据对象" class="headerlink" title="内置数据对象"></a>内置数据对象</h1><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Set</span>(数据);</span><br><span class="line"><span class="comment">//如果数据是一个数组，则将里面重复的部分去掉，如果是一串字符串，则分解这一段字符串</span></span><br></pre></td></tr></table></figure>

<h2 id="size-属性"><a href="#size-属性" class="headerlink" title="size 属性"></a>size 属性</h2><p>set.size</p>
<p>新创建的 Set 数据类型不能使用 length 来获取长度，则使用 size 来获取长度</p>
<p>获取调用它的对象或者数组</p>
<h2 id="has-方法"><a href="#has-方法" class="headerlink" title="has 方法"></a>has 方法</h2><p>set.has()</p>
<p>查询某个元素是否在 set 中</p>
<h2 id="add-方法"><a href="#add-方法" class="headerlink" title="add 方法"></a>add 方法</h2><p>set.add()</p>
<p>在 set 中添加一个元素</p>
<h2 id="delete-方法"><a href="#delete-方法" class="headerlink" title="delete 方法"></a>delete 方法</h2><p>set.delete(‘删除的元素值’)</p>
<p>删除 set 中的一个元素</p>
<h2 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear 方法"></a>clear 方法</h2><p>set.clear()</p>
<p>删除 set 中所有的元素</p>
<h2 id="set-不能使用下标来检索数据"><a href="#set-不能使用下标来检索数据" class="headerlink" title="set 不能使用下标来检索数据"></a>set 不能使用下标来检索数据</h2><p>如果你的需求是实际按顺序存储值，并且检索它，那么最好的用法是用数组、</p>
<p>没有必要从 set 中获取值</p>
<p>当然，set 也是可以用 for of 来遍历里面的元素的</p>
<p>也可以用拓展运算符对 set 结构进行解构<br><img lazyload alt="image" data-src="https://s1.328888.xyz/2022/05/10/H8z23.png"></p>
<h1 id="map-对象"><a href="#map-对象" class="headerlink" title="map 对象"></a>map 对象</h1><p>Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值（对象或者原始数据类型（string,number,…））都可以作为一个键或一个值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化一个map对象</span></span><br><span class="line"><span class="keyword">let</span> mapp = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="comment">//map通过set方法来添加键值对</span></span><br><span class="line">mapp.<span class="title function_">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="comment">//map通过get方法获取键对应的值</span></span><br><span class="line">mapp.<span class="title function_">get</span>(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>同样，map 对象也能使用 set 对象的方法和属性(size,has()…)</p>
<h2 id="可以使用数组作为-map-的键名"><a href="#可以使用数组作为-map-的键名" class="headerlink" title="可以使用数组作为 map 的键名"></a>可以使用数组作为 map 的键名</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">mapp.<span class="title function_">set</span>(arr, <span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mapp.<span class="title function_">get</span>(arr));</span><br></pre></td></tr></table></figure>

<p>这里数组名仅仅只是当作键的名字而已</p>
<p><img lazyload alt="image" data-src="https://s1.328888.xyz/2022/05/11/HsxsO.png"></p>
<h2 id="甚至页面元素也可以作为键名来使用"><a href="#甚至页面元素也可以作为键名来使用" class="headerlink" title="甚至页面元素也可以作为键名来使用"></a>甚至页面元素也可以作为键名来使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rest.<span class="title function_">set</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;h1&quot;</span>), <span class="string">&quot;你好！&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="https://s1.328888.xyz/2022/05/11/H7ykA.png"></p>
<h2 id="批量添加-map-元素"><a href="#批量添加-map-元素" class="headerlink" title="批量添加 map 元素"></a>批量添加 map 元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> end2 = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="string">&quot;name1&quot;</span>, <span class="string">&quot;张三&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;name2&quot;</span>, <span class="string">&quot;李四&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;name3&quot;</span>, <span class="string">&quot;王五&quot;</span>],</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="https://s1.328888.xyz/2022/05/11/H77UZ.png"></p>
<h2 id="object-转-map"><a href="#object-转-map" class="headerlink" title="object 转 map"></a>object 转 map</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>, <span class="attr">job</span>: <span class="string">&quot;医生&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mpp = <span class="keyword">new</span> <span class="title class_">Map</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj));</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="https://s1.328888.xyz/2022/05/11/H7IqC.png"></p>
<h2 id="遍历-map"><a href="#遍历-map" class="headerlink" title="遍历 map"></a>遍历 map</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, value] <span class="keyword">of</span> mpp.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="https://s1.328888.xyz/2022/05/11/H7anm.png"></p>
<h2 id="可以用拓展运算符（…）把-map-转换成数组"><a href="#可以用拓展运算符（…）把-map-转换成数组" class="headerlink" title="可以用拓展运算符（…）把 map 转换成数组"></a>可以用拓展运算符（…）把 map 转换成数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...mpp]);</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="https://s1.328888.xyz/2022/05/11/HIt3S.png"></p>
<h2 id="也可以使用-keys-values-entries-方法"><a href="#也可以使用-keys-values-entries-方法" class="headerlink" title="也可以使用 keys,values,entries 方法"></a>也可以使用 keys,values,entries 方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...mpp.<span class="title function_">keys</span>()]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...mpp.<span class="title function_">values</span>()]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...mpp.<span class="title function_">entries</span>()]);</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="https://s1.328888.xyz/2022/05/11/HI7CF.png"></p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/2022/05/16/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数默认值"><a href="#函数默认值" class="headerlink" title="函数默认值"></a>函数默认值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="keyword">const</span> show = <span class="keyword">function</span> (<span class="params">one</span>) &#123;</span><br><span class="line">  one = one || <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">const</span> show = <span class="keyword">function</span> (<span class="params">one = <span class="number">5</span></span>) &#123;&#125;;</span><br><span class="line"><span class="comment">// one此时默认值就为5</span></span><br><span class="line">传参的时候如果不想输入，而直接使用默认值，则传过去一个<span class="literal">undefined</span>就可以</span><br></pre></td></tr></table></figure>

<h2 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h2><p>如果函数的接受参数是一个复合对象</p>
<p>则这个参数会指向那个对象的地址</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> show = <span class="keyword">function</span> (<span class="params">obj2</span>) &#123;</span><br><span class="line">  obj2.<span class="property">name</span> = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时 obj 的 name 也被修改成李四了;</p>
<p>和这个情况是一样的;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = obj;</span><br><span class="line"></span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&quot;李四&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="https://s1.328888.xyz/2022/05/16/qMDnM.png"></p>
<p>函数也是对象</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">toUpperCase</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> two = <span class="keyword">function</span> (<span class="params">str, fn</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>(str));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">two</span>(<span class="string">&quot;agecdfg&quot;</span>, one);</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="https://s1.328888.xyz/2022/05/18/D0XEg.png"></p>
<p>如果当作事件来看，会好理解很多</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;);</span><br><span class="line"><span class="comment">//本身add...就是一个方法（也可以称为函数），第二个参数就是要实现的函数</span></span><br></pre></td></tr></table></figure>

<p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。</p>
<p>在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包让你可以在一个内层函数中访问到其外层函数的作用域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="keyword">function</span> (<span class="params">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(string, name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greet</span>(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&quot;Hello&quot;</span>)(<span class="string">&quot;小王&quot;</span>);</span><br><span class="line"><span class="title function_">greet2</span>(<span class="string">&quot;小王&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="https://s1.328888.xyz/2022/05/19/D3Hik.png"></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>闭包让你可以在一个内层函数中访问到其外层函数的作用域闭包让你可以在一个内层函数中访问到其外层函数的作用域</p>
<p>闭包是封闭变量，执行上下文的环境，在其中创建了一个函数,即使在那个执行上下文消失之后（即使在函数之后），执行上下文所属的已经返回</p>
<p>闭包使函数可以访问所有变量，其父函数</p>
<p>所以函数保持对其外部范围的引用，即使在那个外部范围消失之后，这基本上保留了整个时间范围链</p>
<h3 id="另一个定义"><a href="#另一个定义" class="headerlink" title="另一个定义"></a>另一个定义</h3><p>类比是闭包确保一个函数永远不会失去连接，到函数诞生地存在的变量，它记得变量，即使在出生地消失之后</p>
<p>就像一个不会失去联系的人到他们的家乡，在这个类比当中，人就是函数，而家乡是函数的父范围,然后该功能不会失去连接到存储在此父级范围中的变量</p>
<h2 id="如果没有函数返回值"><a href="#如果没有函数返回值" class="headerlink" title="如果没有函数返回值"></a>如果没有函数返回值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> c = <span class="number">777</span>;</span><br><span class="line">  a = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    consnole.<span class="title function_">log</span>(c * <span class="number">2</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">a</span>(); <span class="comment">//会提示未定义</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">b</span>();当调用完a之后，会关闭b的变量环境</span><br><span class="line"><span class="title function_">a</span>(); <span class="comment">//输出结果是c*2的值</span></span><br></pre></td></tr></table></figure>

<h2 id="内部作用域的属性在-scopes-里面"><a href="#内部作用域的属性在-scopes-里面" class="headerlink" title="内部作用域的属性在 scopes 里面"></a>内部作用域的属性在 scopes 里面</h2><h3 id="closure：获取父函数的的变量"><a href="#closure：获取父函数的的变量" class="headerlink" title="closure：获取父函数的的变量"></a>closure：获取父函数的的变量</h3><p>双括号代表是一个内部属性,无法从代码中访问</p>
<h2 id="立即调用函数表达式，简称-IIFE"><a href="#立即调用函数表达式，简称-IIFE" class="headerlink" title="立即调用函数表达式，简称 IIFE"></a>立即调用函数表达式，简称 IIFE</h2><p>用括号去欺骗 JavaScript 来进行使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  执行语句;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;123&quot;</span>))();</span><br></pre></td></tr></table></figure>

<p>立即创建，立即调用</p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>对象</title>
    <url>/2022/04/25/%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 对象名 = &#123;属性<span class="number">1</span>，属性<span class="number">2</span>，属性<span class="number">3.</span>..&#125;</span><br></pre></td></tr></table></figure>

<p>数组通过下标访问数据，对象通过属性名访问数据</p>
<h2 id="访问数据的方法"><a href="#访问数据的方法" class="headerlink" title="访问数据的方法"></a>访问数据的方法</h2><ol>
<li>对象名.属性名</li>
<li>对象名[‘属性名’] (可以用一个变量来存储属性名)</li>
</ol>
<p>对面里面也可以存函数，这个函数叫做这个对象的方法</p>
<h2 id="方法里面的-this-指向"><a href="#方法里面的-this-指向" class="headerlink" title="方法里面的 this 指向"></a>方法里面的 this 指向</h2><p>谁调用方法，this 就代表哪个对象</p>
<p>数组实际上是一种特殊的对象，它们有自己的方法<br>例如：push,unshift</p>
<p>一个对象的方法如果被赋值给了其他变量，则这个变量获得的值只是一个全局的函数，并不是对象的方法本身</p>
<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>手动并明确的设置 this 关键字</p>
<p>call(需要指向的 this,调用方法时的参数)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化两个对象</span></span><br><span class="line"><span class="keyword">const</span> name = &#123;</span><br><span class="line">  <span class="attr">namne</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">  <span class="attr">arr</span>: [],</span><br><span class="line">  <span class="title function_">show</span>(<span class="params">name, sex</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: name, <span class="attr">sex</span>: sex &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name2 = &#123;</span><br><span class="line">  <span class="attr">namne2</span>: <span class="string">&quot;小A&quot;</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">  <span class="attr">arr</span>: [],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把name里面的函数提出来</span></span><br><span class="line"><span class="keyword">const</span> show2 = name.<span class="property">show</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用show2，并使用call将show方法里面的this指向name2和name</span></span><br><span class="line"><span class="comment">// 后面的参数是方法接收的参数</span></span><br><span class="line">show2.<span class="title function_">call</span>(name, <span class="string">&quot;小南&quot;</span>, <span class="string">&quot;女&quot;</span>);</span><br><span class="line"></span><br><span class="line">show2.<span class="title function_">call</span>(name2, <span class="string">&quot;小A&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"></span><br><span class="line">name.<span class="title function_">show</span>(<span class="string">&quot;小王&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name2);</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="https://s1.328888.xyz/2022/05/22/dR9Jv.png"></p>
<p>可以看见这里 name,和 name2 对象里面 arr 数组通过 show2 的方法添加了元素</p>
<p>通过 call，能够使用另一个对象里面的方法</p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h2><p>bind 方法创建一个新的函数</p>
<p>在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> show = name.<span class="property">show</span>.<span class="title function_">bind</span>(name, <span class="string">&quot;小南&quot;</span>);</span><br><span class="line"><span class="comment">//此时show等同于name对象里面的show,this会指向name对象,而后面的参数会变成新函数的参数</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2022/05/12/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="字符串的一些方法"><a href="#字符串的一些方法" class="headerlink" title="字符串的一些方法"></a>字符串的一些方法</h1><h2 id="slice-截取"><a href="#slice-截取" class="headerlink" title="slice 截取"></a>slice 截取</h2><p>slice(起始位置，结束位置)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">slice</span>(<span class="number">3</span>, <span class="number">7</span>)); <span class="comment">// lowo</span></span><br></pre></td></tr></table></figure>

<p>语法</p>
<p>str.slice(beginIndex[, endIndex])</p>
<p>截取这个区间下标的元素：[beginIndex,endIndex)</p>
<ul>
<li><p>beginIndex</p>
<ul>
<li>从该索引（以 0 为基数）处开始提取原字符串中的字符。如果值为负数，会被当做 strLength + beginIndex 看待，这里的 strLength 是字符串的长度（例如， 如果 beginIndex 是 -3 则看作是：strLength - 3）</li>
</ul>
</li>
<li><p>endIndex</p>
<ul>
<li>可选。在该索引（以 0 为基数）处结束提取字符串。如果省略该参数，slice() 会一直提取到字符串末尾。如果该参数为负数，则被看作是 strLength + endIndex，这里的 strLength 就是字符串的长度(例如，如果 endIndex 是 -3，则是, strLength - 3)。</li>
</ul>
</li>
</ul>
<h2 id="toUpperCase-字符串转大写-x2F-toLowerCase-字符串转小写"><a href="#toUpperCase-字符串转大写-x2F-toLowerCase-字符串转小写" class="headerlink" title="toUpperCase()字符串转大写&#x2F;toLowerCase()字符串转小写"></a>toUpperCase()字符串转大写&#x2F;toLowerCase()字符串转小写</h2><p>语法</p>
<p>str.toUpperCase()字符串转大写</p>
<p>str.toLowerCase()字符串转小写</p>
<h2 id="split-分隔符"><a href="#split-分隔符" class="headerlink" title="split(分隔符)"></a>split(分隔符)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;123 456 789&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">//[123,456,789]</span></span><br></pre></td></tr></table></figure>

<p>通过参数来对字符串进行分割, 并以数组的形式打印出来;</p>
<h2 id="padStart-x2F-padEnd-填充方法"><a href="#padStart-x2F-padEnd-填充方法" class="headerlink" title="padStart&#x2F;padEnd 填充方法"></a>padStart&#x2F;padEnd 填充方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;123 456 789&quot;</span>;</span><br><span class="line">str.<span class="title function_">padStart</span>(<span class="number">5</span>, <span class="number">111</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">length</span>);</span><br><span class="line"><span class="comment">// 11111123 456 789</span></span><br><span class="line"><span class="comment">// 第一个参数是字符串填充到多少长度，如果字符串本身长度超过第一个参数，则还是原来的字符串</span></span><br><span class="line"><span class="comment">// 第二个参数是填充的内容</span></span><br></pre></td></tr></table></figure>

<p>会在字符串开头或者末尾添加参数</p>
<h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h2><p>重复添加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;你好&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">repeat</span>(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="https://s1.328888.xyz/2022/05/15/qkVSq.png"></p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>拓展运算符</title>
    <url>/2022/05/08/%E6%8B%93%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="在右边时：…变量名"><a href="#在右边时：…变量名" class="headerlink" title="在右边时：…变量名"></a>在右边时：…变量名</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...arr];</span><br><span class="line"><span class="comment">//arr1 = [1,2,3,1,2,3,4]</span></span><br><span class="line">...arr把整个arr的数组解构成一个个的元素，这个也可以用于解构对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="在左边时：…变量名"><a href="#在左边时：…变量名" class="headerlink" title="在左边时：…变量名"></a>在左边时：…变量名</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">const</span> [a, b, c, ...arr2] = arr;</span><br><span class="line"><span class="comment">//arr2 = [4,5,6,7]</span></span><br><span class="line">在左边时将剩余的数组元素合并成一个数组;</span><br><span class="line">当作为函数的参数使用时，会将传递的实参全部存入，和<span class="variable language_">arguments</span>类似</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>遍历数组和对象</title>
    <url>/2022/05/09/%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="For-of"><a href="#For-of" class="headerlink" title="For-of"></a>For-of</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> 变量名||&#123;变量<span class="number">1</span>，变量<span class="number">2</span>&#125; <span class="keyword">of</span> 数组名||数组名.<span class="title function_">entries</span>())&#123;</span><br><span class="line"><span class="number">1</span>：下标</span><br><span class="line"><span class="number">2</span>：下标对应的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>把对象先转换成数组的形式，然后进行遍历</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">keys</span></span><br><span class="line">	只获取对象中属性的名称，也就是键名</span><br><span class="line"><span class="title class_">Object</span>.<span class="property">values</span></span><br><span class="line">	把对象的格式转成数组的格式，第一层的属性名被替换成下标</span><br><span class="line"><span class="title class_">Object</span>.<span class="property">entries</span></span><br><span class="line">	将全部对象全部转换成数组</span><br></pre></td></tr></table></figure>

<p><img lazyload alt="image" data-src="https://s1.328888.xyz/2022/05/10/HULz4.png"><br><img lazyload alt="image" data-src="https://s1.328888.xyz/2022/05/10/HUJJ3.png"></p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2022/04/25/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="创建数组的方法"><a href="#创建数组的方法" class="headerlink" title="创建数组的方法"></a>创建数组的方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> 数组名 = [元素<span class="number">1</span>，元素<span class="number">2</span>，元素<span class="number">3.</span>..]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> 数组名 <span class="keyword">new</span> <span class="title class_">Array</span>(元素<span class="number">1</span>，元素<span class="number">2</span>，元素<span class="number">3.</span>..)</span><br></pre></td></tr></table></figure>

<p>数组下标通常以 0 开始</p>
<p>数组名.length(length 能获取数组中元素的个数)</p>
<p>以 const 声明的数组，后面可以改变它的值</p>
<p>数组内的元素可以是任意表达式，例如：函数，字符串，数字等等</p>
<hr>
<h1 id="内置数组函数"><a href="#内置数组函数" class="headerlink" title="内置数组函数"></a>内置数组函数</h1><h2 id="在数组末尾添加元素"><a href="#在数组末尾添加元素" class="headerlink" title="在数组末尾添加元素"></a>在数组末尾添加元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">数组名.<span class="title function_">push</span>(要添加的元素);</span><br></pre></td></tr></table></figure>

<h2 id="在数组开头添加元素"><a href="#在数组开头添加元素" class="headerlink" title="在数组开头添加元素"></a>在数组开头添加元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">数组名.<span class="title function_">unshift</span>(要添加的元素);</span><br></pre></td></tr></table></figure>

<p><strong>上面两个内置函数有返回值，返回值是新数组的长度</strong></p>
<h2 id="删除数组最后一个元素"><a href="#删除数组最后一个元素" class="headerlink" title="删除数组最后一个元素"></a>删除数组最后一个元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">数组名.<span class="title function_">pop</span>();</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h2 id="删除数组的第一个元素"><a href="#删除数组的第一个元素" class="headerlink" title="删除数组的第一个元素"></a>删除数组的第一个元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">数组名.<span class="title function_">unshift</span>(要删除的元素);</span><br></pre></td></tr></table></figure>

<p><strong>上面两个内置函数有返回值，返回值是被删除的元素</strong></p>
<h2 id="删除数组的第一个元素-1"><a href="#删除数组的第一个元素-1" class="headerlink" title="删除数组的第一个元素"></a>删除数组的第一个元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">数组名.<span class="title function_">unshift</span>(要删除的元素);</span><br></pre></td></tr></table></figure>

<h2 id="查询数组中某个元素的下标"><a href="#查询数组中某个元素的下标" class="headerlink" title="查询数组中某个元素的下标"></a>查询数组中某个元素的下标</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">数组名.<span class="title function_">indexOf</span>(要查找的元素);</span><br></pre></td></tr></table></figure>

<p><strong>如果有，则返回该元素对应的下标</strong></p>
<p><strong>如果没找到该元素，则返回-1</strong></p>
<h2 id="查询数组中是否包含某个元素"><a href="#查询数组中是否包含某个元素" class="headerlink" title="查询数组中是否包含某个元素"></a>查询数组中是否包含某个元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">数组名.<span class="title function_">includes</span>(要查找的元素);</span><br></pre></td></tr></table></figure>

<p>有则返回 true,<br>无则返回 false</p>
<h2 id="数组进阶"><a href="#数组进阶" class="headerlink" title="数组进阶"></a>数组进阶</h2>]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
